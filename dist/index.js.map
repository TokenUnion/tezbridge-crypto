{"version":3,"sources":["PsddFKi3/codec.js","PsddFKi3/crypto.js","PsddFKi3/localop.js","index.js"],"names":["TextEncoder","TextDecoder","process","env","NODE_ENV","window","util","require","fromHex","x","Uint8Array","elliptic","utils","toArray","toHex","bytesConcat","y","tmp","length","set","bs58checkEncode","input","prefix_info","prefix_bytes","prefix","bs58check","encode","Buffer","from","bs58checkDecode","decode","slice","bs58checkPrefixPick","bytes","block_hash","operation_hash","operation_list_hash","operation_list_list_hash","protocol_hash","context_hash","ed25519_public_key_hash","secp256k1_public_key_hash","p256_public_key_hash","cryptobox_public_key_hash","ed25519_seed","ed25519_public_key","secp256k1_secret_key","p256_secret_key","ed25519_encrypted_seed","secp256k1_encrypted_secret_key","p256_encrypted_secret_key","secp256k1_public_key","p256_public_key","secp256k1_scalar","secp256k1_element","ed25519_secret_key","ed25519_signature","secp256k1_signature","p256_signature","generic_signature","chain_id","contract_hash","prefix_mapping","matched_mapping","Net","id","tz1","tz2","tz3","KT1","B","o","P","Lo","Co","LLo","SSp","edsk","edpk","spsk","p2sk","GSp","sppk","p2pk","edesk","spesk","p2esk","sig","p2sig","edsig","spsig1","key","len","name","getContractHexKey","contract","hex","hex_key","undefined","map","join","watermark","block_header","endorsement","operation","custom","op_mapping","op_mapping_reverse","result","prim_mapping","annots","prim_mapping_reverse","false","true","encodeZarithUInt","value","num","binary","BN","toString","replace","pad","reversed","padStart","match","reverse","i","parseInt","encodeZarithInt","positive_mark","toTzStrValue","len_mapping","tag","tz_prefix","e","toTzBytes","source","is_key_hash","encodeRawBytes","rec","Array","push","Object","prim","args","inner_result","forEach","arg","annots_bytes","args_len","address","key_hash","signature","int","num_hex","string","string_bytes","string_hex","call","toUpperCase","decodeRawBytes","index","read","b","op","apply","annots_len","string_hex_lst","string_result","split","int_len","data","match_result","string_raw","first_bytes","is_positive","valid_bytes","checknext","limit","seq_lst","genRandomBytes","deriveKeyByPBKDF2","crypto","getRandomValues","password","salt","subtle","importKey","then","deriveBits","iterations","hash","randomBytes","passowrd","Promise","resolve","reject","pbkdf2","err","derived_key","blake2bHash","blake","blake2b","genMnemonic","strength","bip39","generateMnemonic","EncryptedBox","constructor","pwd","secret_key_bytes","prepared","encrypt","_","encrypted","codec","show","reveal","new_pwd","encrypted_msg","decrypted_key","secretbox","open","revealKey","raw_key","getKeyFromSeed","getKeyFromSecretKey","Key","secret_key","pub_key","ed25519","secp256k1","p256","getSecretKey","getPublicKey","getKeyFromEd25519","eddsa","key_pair","nacl","sign","keyPair","secretKey","publicKey","getKeyFromSecp256k1","ec","keyFromPrivate","concat","getPublic","getX","getKeyFromP256","decryptKey","encrypted_bytes","key_mapping","encryptKey","scheme","unencrypted","sk","seed","seed_bytes","fromSeed","getSeedFromWords","words","mnemonic","mnemonicToSeed","getKeyFromWords","genRandomKey","signOperation","input_operation","operation_bytes","sig_mapping","fromSecretKey","sig_bytes","detached","r","s","canonical","op_hex2bytes","transaction","fee","counter","gas_limit","storage_limit","amount","destination","parameters","origination","managerPubkey","balance","spendable","delegatable","delegate","script","code","storage","delegation","public_key","forgeOperation","contents","branch","branch_bytes","kind","op_hex","toLowerCase","parseOperationBytes","readUInt","output","op_tag","code_len","storage_len","export_fns","protocol_mapping","PsddFKi3","PsddFKi3_codec","PsddFKi3_crypto","localop","PsddFKi3_localop","modProtocol","protocol"],"mappings":"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ACA,KAAA,QACA,KAAA,OACA,KAAA,OACA,KAAA,OACA,KAAA,OACA,KAAA,SACA,KAAA,UACA,KAAA,SACA,GAAA,SACA,GAAA,MACA,GAAA,MACA,GAAA,SACA,GAAA,MACA,GAAA,UACA,GAAA,MACA,GAAA,MACA,GAAA,kBACA,GAAA,UACA,KAAA,SACA,KAAA,OACA,KAAA,iBACA,KAAA,kBACA,KAAA,mBACA,KAAA,MACA,GAAA,OACA,GAAA,MACA,GAAA,OACA,GAAA,YACA,GAAA,YACA,GAAA,KACA,GAAA,OACA,GAAA,WACA,GAAA,KACA,GAAA,MACA,KAAA,KACA,KAAA,WACA,KAAA,KACA,KAAA,UACA,KAAA,UACA,KAAA,UACA,GAAA,MACA,GAAA,SACA,GAAA,KACA,GAAA,OACA,GAAA,OACA,GAAA,MACA,GAAA,MACA,GAAA,KACA,GAAA,MACA,GAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,OACA,KAAA,MACA,GAAA,MACA,GAAA,KACA,GAAA,OACA,GAAA,OACA,GAAA,QACA,GAAA,OACA,GAAA,OACA,GAAA,SACA,GAAA,SACA,GAAA,OACA,KAAA,iBACA,KAAA,MACA,KAAA,OACA,KAAA,kBACA,KAAA,eACA,KAAA,OACA,GAAA,SACA,GAAA,MACA,GAAA,OACA,GAAA,YACA,GAAA,UACA,GAAA,WACA,GAAA,QACA,GAAA,OACA,GAAA,SACA,GAAA,OACA,KAAA,WACA,KAAA,MACA,KAAA,MACA,KAAA,WACA,KAAA,SACA,KAAA,OACA,GAAA,MACA,GAAA,UACA,GAAA,MACA,GAAA,SACA,GAAA,KACA,GAAA,OACA,GAAA,MACA,GAAA,YACA,GAAA,SACA,GAAA,QACA,KAAA,QACA,KAAA,YACA,KAAA,OACA,KAAA,YACA,KAAA,UACA,KAAA,SAEDC,EAAqB,MACnBC,MAAAA,EAAS,GACV,IAAA,MAAMjB,KAAOe,EAChBE,EAAOF,EAAWf,IAAQA,EAErBiB,OAAAA,GALkB,GAQrBC,EAAe,CACb,KAAA,MACA,KAAA,SACA,KAAA,MACA,KAAA,CAACh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","file":"index.js","sourceRoot":"../src","sourcesContent":["// @flow\n\nconst [TextEncoder, TextDecoder] = (() => {\n  if (process.env.NODE_ENV === 'browser') {\n    return [\n      window.TextEncoder,\n      window.TextDecoder\n    ]\n  } else {\n    const util = require('util')\n    return [\n      util.TextEncoder,\n      util.TextDecoder\n    ]\n  }\n})()\n\n\nimport BN from 'bn.js'\nimport bs58check from 'bs58check'\nimport elliptic from 'elliptic'\nimport type { Micheline } from '../types'\n\n\nexport function fromHex(x : string) {\n  return new Uint8Array(elliptic.utils.toArray(x, 'hex'))\n}\nexport function toHex(x : Uint8Array) {\n  return elliptic.utils.toHex(x)\n}\n\nexport function bytesConcat(x : Uint8Array, y : Uint8Array) {\n  const tmp = new Uint8Array(x.length + y.length)\n  tmp.set(x, 0)\n  tmp.set(y, x.length)\n  return tmp\n}\n\nexport function bs58checkEncode(input : Uint8Array, prefix_info : Uint8Array | string) {\n  const prefix_bytes = typeof prefix_info === 'string' ? prefix[prefix_info] : prefix_info\n  return bs58check.encode(Buffer.from(bytesConcat(prefix_bytes, input)))\n}\n\nexport function bs58checkDecode(input : string, prefix? : Uint8Array) {\n  return bs58check.decode(input).slice(prefix ? prefix.length : bs58checkPrefixPick(input).bytes.length)\n}\n\nexport const prefix = {\n  block_hash: new Uint8Array([1, 52]), // B(51)\n  operation_hash: new Uint8Array([5, 116]), // o(51)\n  operation_list_hash: new Uint8Array([133, 233]), // Lo(52)\n  operation_list_list_hash: new Uint8Array([29, 159, 109]), // LLo(53)\n  protocol_hash: new Uint8Array([2, 170]), // P(51)\n  context_hash: new Uint8Array([79, 199]), // Co(52)\n\n  ed25519_public_key_hash: new Uint8Array([6, 161, 159]), // tz1(36)\n  secp256k1_public_key_hash: new Uint8Array([6, 161, 161]), // tz2(36)\n  p256_public_key_hash: new Uint8Array([6, 161, 164]), // tz3(36)\n\n  cryptobox_public_key_hash: new Uint8Array([153, 103]), // id(30)\n\n  ed25519_seed: new Uint8Array([13, 15, 58, 7]), // edsk(54)\n  ed25519_public_key: new Uint8Array([13, 15, 37, 217]), // edpk(54)\n  secp256k1_secret_key: new Uint8Array([17, 162, 224, 201]), // spsk(54)\n  p256_secret_key: new Uint8Array([16, 81, 238, 189]), // p2sk(54)\n\n  ed25519_encrypted_seed: new Uint8Array([7, 90, 60, 179, 41]), // edesk(88)\n  secp256k1_encrypted_secret_key: new Uint8Array([9, 237, 241, 174, 150]), // spesk(88)\n  p256_encrypted_secret_key: new Uint8Array([9, 48, 57, 115, 171]), // p2esk(88)\n\n  secp256k1_public_key: new Uint8Array([3, 254, 226, 86]), // sppk(55)\n  p256_public_key: new Uint8Array([3, 178, 139, 127]), // p2pk(55)\n  secp256k1_scalar: new Uint8Array([38, 248, 136]), // SSp(53)\n  secp256k1_element: new Uint8Array([5, 92, 0]), // GSp(54)\n\n  ed25519_secret_key: new Uint8Array([43, 246, 78, 7]), // edsk(98)\n  ed25519_signature: new Uint8Array([9, 245, 205, 134, 18]), // edsig(99)\n  secp256k1_signature: new Uint8Array([13, 115, 101, 19, 63]), // spsig1(99)\n  p256_signature: new Uint8Array([54, 240, 44, 52]), // p2sig(98)\n  generic_signature: new Uint8Array([4, 130, 43]), // sig(96)\n\n  chain_id: new Uint8Array([7, 82, 0]), // Net(15)\n\n  contract_hash: new Uint8Array([2, 90, 121]) // KT1(36)\n}\n\nexport function bs58checkPrefixPick(input : string) : {bytes: Uint8Array, name: string} {\n  const prefix_mapping = {\n    [15]: {\n      Net: 'chain_id'\n    },\n    [30]: {\n      id: 'cryptobox_public_key_hash'\n    },\n    [36]: {\n      tz1: 'ed25519_public_key_hash',\n      tz2: 'secp256k1_public_key_hash',\n      tz3: 'p256_public_key_hash',\n      KT1: 'contract_hash'\n    },\n    [51]: {\n      B: 'block_hash',\n      o: 'operation_hash',\n      P: 'protocol_hash'\n    },\n    [52]: {\n      Lo: 'operation_list_hash',\n      Co: 'context_hash'\n    },\n    [53]: {\n      LLo: 'operation_list_list_hash',\n      SSp: 'secp256k1_scalar'\n    },\n    [54]: {\n      edsk: 'ed25519_seed',\n      edpk: 'ed25519_public_key',\n      spsk: 'secp256k1_secret_key',\n      p2sk: 'p256_secret_key',\n      GSp: 'secp256k1_element'\n    },\n    [55]: {\n      sppk: 'secp256k1_public_key',\n      p2pk: 'p256_public_key'\n    },\n    [88]: {\n      edesk: 'ed25519_encrypted_seed',\n      spesk: 'secp256k1_encrypted_secret_key',\n      p2esk: 'p256_encrypted_secret_key'\n    },\n    [96]: {\n      sig: 'generic_signature'\n    },\n    [98]: {\n      edsk: 'ed25519_secret_key',\n      p2sig: 'p256_signature'\n    },\n    [99]: {\n      edsig: 'ed25519_signature',\n      spsig1: 'secp256k1_signature'\n    }\n  }\n\n  const matched_mapping = prefix_mapping[input.length]\n  if (matched_mapping) {\n    for (const key in matched_mapping) {\n      const len = key.length\n      if (input.slice(0, len) === key)\n        return {bytes: prefix[matched_mapping[key]], name:matched_mapping[key]} \n    }\n  }\n\n  throw `No prefix found for: ${input}`\n}\n\nexport function getContractHexKey(contract : string) {\n  if (contract.length !== 36 || contract.slice(0, 3) !== 'KT1')\n    throw `invalid contract: ${contract}`\n\n  const bytes = bs58checkDecode(contract, prefix.contract_hash)\n  const hex = toHex(bytes)\n  const hex_key = [[0,2], [2,4], [4,6], [6,8], [8,10], [10,undefined]].map(x => hex.slice(x[0], x[1])).join('/')\n\n  return hex_key\n}\n\nexport const watermark = {\n  block_header(chain_id : Uint8Array) {\n    return bytesConcat(new Uint8Array([1]), chain_id)\n  },\n  endorsement(chain_id : Uint8Array) {\n    return bytesConcat(new Uint8Array([2]), chain_id)\n  },\n  operation() {\n    return new Uint8Array([3])\n  },\n  custom(x : Uint8Array) {\n    return x\n  }\n}\n\nconst op_mapping = {\n  '00':'parameter',\n  '01':'storage',\n  '02':'code',\n  '03':'False',\n  '04':'Elt',\n  '05':'Left',\n  '06':'None',\n  '07':'Pair',\n  '08':'Right',\n  '09':'Some',\n  '0A':'True',\n  '0B':'Unit',\n  '0C':'PACK',\n  '0D':'UNPACK',\n  '0E':'BLAKE2B',\n  '0F':'SHA256',\n  '10':'SHA512',\n  '11':'ABS',\n  '12':'ADD',\n  '13':'AMOUNT',\n  '14':'AND',\n  '15':'BALANCE',\n  '16':'CAR',\n  '17':'CDR',\n  '18':'CHECK_SIGNATURE',\n  '19':'COMPARE',\n  '1A':'CONCAT',\n  '1B':'CONS',\n  '1C':'CREATE_ACCOUNT',\n  '1D':'CREATE_CONTRACT',\n  '1E':'IMPLICIT_ACCOUNT',\n  '1F':'DIP',\n  '20':'DROP',\n  '21':'DUP',\n  '22':'EDIV',\n  '23':'EMPTY_MAP',\n  '24':'EMPTY_SET',\n  '25':'EQ',\n  '26':'EXEC',\n  '27':'FAILWITH',\n  '28':'GE',\n  '29':'GET',\n  '2A':'GT',\n  '2B':'HASH_KEY',\n  '2C':'IF',\n  '2D':'IF_CONS',\n  '2E':'IF_LEFT',\n  '2F':'IF_NONE',\n  '30':'INT',\n  '31':'LAMBDA',\n  '32':'LE',\n  '33':'LEFT',\n  '34':'LOOP',\n  '35':'LSL',\n  '36':'LSR',\n  '37':'LT',\n  '38':'MAP',\n  '39':'MEM',\n  '3A':'MUL',\n  '3B':'NEG',\n  '3C':'NEQ',\n  '3D':'NIL',\n  '3E':'NONE',\n  '3F':'NOT',\n  '40':'NOW',\n  '41':'OR',\n  '42':'PAIR',\n  '43':'PUSH',\n  '44':'RIGHT',\n  '45':'SIZE',\n  '46':'SOME',\n  '47':'SOURCE',\n  '48':'SENDER',\n  '49':'SELF',\n  '4A':'STEPS_TO_QUOTA',\n  '4B':'SUB',\n  '4C':'SWAP',\n  '4D':'TRANSFER_TOKENS',\n  '4E':'SET_DELEGATE',\n  '4F':'UNIT',\n  '50':'UPDATE',\n  '51':'XOR',\n  '52':'ITER',\n  '53':'LOOP_LEFT',\n  '54':'ADDRESS',\n  '55':'CONTRACT',\n  '56':'ISNAT',\n  '57':'CAST',\n  '58':'RENAME',\n  '59':'bool',\n  '5A':'contract',\n  '5B':'int',\n  '5C':'key',\n  '5D':'key_hash',\n  '5E':'lambda',\n  '5F':'list',\n  '60':'map',\n  '61':'big_map',\n  '62':'nat',\n  '63':'option',\n  '64':'or',\n  '65':'pair',\n  '66':'set',\n  '67':'signature',\n  '68':'string',\n  '69':'bytes',\n  '6A':'mutez',\n  '6B':'timestamp',\n  '6C':'unit',\n  '6D':'operation',\n  '6E':'address',\n  '6F':'SLICE',\n}\nconst op_mapping_reverse = (() => {\n  const result = {}\n  for (const key in op_mapping) {\n    result[op_mapping[key]] = key\n  }\n  return result\n})()\n\nconst prim_mapping = {\n  '00': 'int',    \n  '01': 'string',             \n  '02': 'seq',             \n  '03': {name: 'prim', len: 0, annots: false},          \n  '04': {name: 'prim', len: 0, annots: true},\n  '05': {name: 'prim', len: 1, annots: false},           \n  '06': {name: 'prim', len: 1, annots: true},   \n  '07': {name: 'prim', len: 2, annots: false},          \n  '08': {name: 'prim', len: 2, annots: true},  \n  '09': {name: 'prim', len: 3, annots: true},\n  '0A': 'bytes'                  \n}\nconst prim_mapping_reverse = {\n  [0]: {\n    false: '03',\n    true: '04'\n  },\n  [1]: {\n    false: '05',\n    true: '06'\n  },\n  [2]: {\n    false: '07',\n    true: '08'\n  },\n  [3]: {\n    true: '09'\n  }\n}\n\n\nexport function encodeZarithUInt(value : string) {\n  const num = new BN(value, 10)\n  const binary = num.toString(2).replace('-', '')\n  const pad = binary.length % 7 ? binary.length + 7 - binary.length % 7 : binary.length\n\n  const splitted = binary.padStart(pad, '0').match(/\\d{7}/g)\n  const reversed = splitted.reverse()\n\n  return reversed.map((x, i) => \n    parseInt((i === reversed.length - 1 ? '0' : '1') + x, 2)\n    .toString(16)\n    .padStart(2, '0')).join('')\n}\n\nexport function encodeZarithInt(value : string) {\n  const num = new BN(value, 10)\n  const positive_mark = num.toString(2)[0] === '-' ? '1' : '0'\n  const binary = num.toString(2).replace('-', '')\n  const pad = binary.length <= 6 ? 6 : \n    (binary.length - 6) % 7 ? binary.length + 7 - (binary.length - 6) % 7 : binary.length\n\n  const splitted = binary.padStart(pad, '0').match(/\\d{6,7}/g)\n  const reversed = splitted.reverse()\n\n  reversed[0] = positive_mark + reversed[0]\n\n  return reversed.map((x, i) => \n    parseInt((i === reversed.length - 1 ? '0' : '1') + x, 2)\n    .toString(16)\n    .padStart(2, '0')).join('')\n}\n\nexport function toTzStrValue(input : string) {\n  const len_mapping = {\n    [44]() {\n      const tag = input.slice(0, 2)\n      if (tag === '00') {\n        const tag = input.slice(2, 4)\n        const tz_prefix = {\n          '00': 'ed25519_public_key_hash', \n          '01': 'secp256k1_public_key_hash', \n          '02': 'p256_public_key_hash'\n        }\n        return bs58checkEncode(fromHex(input.slice(4)), tz_prefix[tag])\n\n      } else if (tag === '01') {\n        return bs58checkEncode(fromHex(input.slice(2, 42)), 'contract_hash')\n\n      } else {\n        throw `Invalid tag(${tag}) for contract id`\n      }\n    },\n    [42]() {\n      const tag = input.slice(0, 2)\n      const tz_prefix = {\n        '00': 'ed25519_public_key_hash', \n        '01': 'secp256k1_public_key_hash', \n        '02': 'p256_public_key_hash'\n      }\n      return bs58checkEncode(fromHex(input.slice(2)), tz_prefix[tag])\n    },\n    [66]() {\n      const tag = input.slice(0, 2)\n      if (tag !== '00')\n        throw `Invalid tag(${tag}) for Ed25519 public key`\n\n      return bs58checkEncode(fromHex(input.slice(2)), 'ed25519_public_key')\n    },\n    [68]() {\n      const tag = input.slice(0, 2)\n      if (tag === '01')\n        return bs58checkEncode(fromHex(input.slice(2)), 'secp256k1_public_key')\n      else if (tag === '02')\n        return bs58checkEncode(fromHex(input.slice(2)), 'p256_public_key')\n      else \n        throw `Invalid tag(${tag}) for Secp256k1 and P256 public key`\n    }\n  }\n\n  try {\n    return len_mapping[input.length]()\n  } catch(e) {\n    throw `Invalid input to decode to Micheline: ${input}`\n  }\n}\n\nexport function toTzBytes(source : string, is_key_hash : boolean = false) {\n  const prefix = bs58checkPrefixPick(source)\n  const bytes = bs58checkDecode(source, prefix.bytes)\n\n  const tag_mapping = {\n    contract_hash: '01',\n    ed25519_public_key_hash: is_key_hash ? '00' : '0000',\n    secp256k1_public_key_hash: is_key_hash ? '01' : '0001',\n    p256_public_key_hash: is_key_hash ? '02' : '0002',\n    ed25519_public_key: '00',\n    secp256k1_public_key: '01',\n    p256_public_key: '02'\n  }\n  const padding_mapping = {\n    contract_hash: '00'\n  }\n\n  return (tag_mapping[prefix.name] || '') + toHex(bytes) + (padding_mapping[prefix.name] || '')\n}\n\nexport function encodeRawBytes(input : Micheline) : string {\n  const rec = (input : Micheline) : string => {\n    const result : Array<string> = []\n\n    if (input instanceof Array) {\n      result.push('02')\n      const bytes = input.map(x => rec(x)).join('')\n      const len = bytes.length / 2\n      result.push(len.toString(16).padStart(8, '0'))\n      result.push(bytes)\n\n    } else if (input instanceof Object) {\n      if (input.prim) {\n\n        if (input.prim === 'LAMBDA') {\n          result.push('09')\n          result.push(op_mapping_reverse[input.prim])\n          if (input.args) {\n            const inner_result = []\n            input.args.forEach(arg => {\n              inner_result.push(rec(arg))\n            })\n            const len = inner_result.join('').length / 2\n            result.push(len.toString(16).padStart(8, '0'))\n            inner_result.forEach(x => result.push(x))\n          }\n\n          const annots_bytes = input.annots \n            ? input.annots.map(x => toHex(new TextEncoder().encode(x))).join('20')\n            : ''\n\n          result.push((annots_bytes.length / 2).toString(16).padStart(8, '0'))\n          annots_bytes && result.push(annots_bytes)\n\n        } else {\n          const args_len = input.args ? input.args.length : 0\n          result.push(prim_mapping_reverse[args_len][!!input.annots])\n          result.push(op_mapping_reverse[input.prim])\n          if (input.args) {\n            input.args.forEach(arg => {\n              result.push(rec(arg))\n            })\n          }\n\n          if (input.annots) {\n            const annots_bytes = input.annots.map(x => \n              toHex(new TextEncoder().encode(x))).join('20')\n            result.push((annots_bytes.length / 2).toString(16).padStart(8, '0'))\n            result.push(annots_bytes)\n          }\n        }\n\n\n      } else if (input.bytes || \n                 input.address || \n                 input.contract || \n                 input.key || \n                 input.key_hash ||\n                 input.signature) {\n\n        const bytes = input.bytes || \n          toTzBytes(input.address || \n                    input.contract || \n                    input.key || \n                    input.key_hash ||\n                    input.signature, input.key_hash)\n\n        const len = bytes.length / 2\n        result.push('0A')\n        result.push(len.toString(16).padStart(8, '0'))\n        result.push(bytes)\n\n      } else if (input.int) {\n\n        const num_hex = encodeZarithInt(input.int)\n        result.push('00')\n        result.push(num_hex)\n\n      } else if (input.string) {\n\n        const string_bytes = new TextEncoder().encode(input.string)\n        const string_hex = [].slice.call(string_bytes).map(x => x.toString(16).padStart(2, '0')).join('')\n        const len = string_bytes.length\n        result.push('01')\n        result.push(len.toString(16).padStart(8, '0'))\n        result.push(string_hex)\n\n      }\n    }\n\n    return result.join('')\n  }\n\n  return rec(input).toUpperCase()\n}\n\nexport function decodeRawBytes(bytes : string) : Micheline {\n  bytes = bytes.toUpperCase()\n  \n  let index = 0\n\n  const read = len => bytes.slice(index, index + len)\n\n  const rec = () => {\n    const b = read(2)\n    const prim = prim_mapping[b]\n    \n    if (prim instanceof Object) {\n\n      index += 2\n      const op = op_mapping[read(2)]\n      index += 2\n\n      if (op === 'LAMBDA') \n        index += 8\n\n      const args = Array.apply(null, new Array(prim.len))\n      const result = {prim: op, args: args.map(() => rec()), annots: undefined}\n\n      if (!prim.len)\n        delete result.args\n\n      if (prim.annots) {\n        const annots_len = parseInt(read(8), 16) * 2\n        index += 8\n\n        const string_hex_lst = read(annots_len).match(/[\\dA-F]{2}/g)\n        index += annots_len\n        \n        if (string_hex_lst) {\n          const string_bytes = new Uint8Array(string_hex_lst.map(x => parseInt(x, 16)))\n          const string_result = new TextDecoder('utf-8').decode(string_bytes)\n          result.annots = string_result.split(' ')\n        }\n      } else {\n        delete result.annots\n      }\n\n      return result\n\n    } else {\n      if (b === '0A') {\n\n        index += 2\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        index += int_len\n        return {bytes: data}\n\n      } else if (b === '01') {\n        index += 2\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        index += int_len\n\n        const match_result = data.match(/[\\dA-F]{2}/g)\n        if (match_result instanceof Array) {\n          const string_raw = new Uint8Array(match_result.map(x => parseInt(x, 16)))\n          return {string: new TextDecoder('utf-8').decode(string_raw)}\n        } else {\n          throw `Input bytes error`\n        }\n\n      } else if (b === '00') {\n        index += 2\n\n        const first_bytes = parseInt(read(2), 16).toString(2).padStart(8, '0')\n        index += 2\n        const is_positive = first_bytes[1] === '0'\n\n        const valid_bytes = [first_bytes.slice(2)]\n\n        let checknext = first_bytes[0] === '1'\n        while (checknext) {\n          const bytes = parseInt(read(2), 16).toString(2).padStart(8, '0')\n          index += 2\n\n          valid_bytes.push(bytes.slice(1))\n          checknext = bytes[0] === '1'\n        }\n\n        const num = new BN(valid_bytes.reverse().join(''), 2)\n        return {int: num.toString(10)}\n      } else if (b === '02') {\n        index += 2\n\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        const limit = index + int_len\n\n        const seq_lst = []\n        while (limit > index) {\n          seq_lst.push(rec())\n        }\n        return seq_lst\n      }\n\n    }\n\n    throw `Invalid raw bytes: Byte:${b} Index:${index}`\n  }\n\n  return rec()\n}\n\nexport default {\n  fromHex,\n  toHex,\n  toTzBytes,\n  toTzStrValue,\n  prefix,\n  watermark,\n  bs58checkEncode,\n  bs58checkDecode,\n  bs58checkPrefixPick,\n  getContractHexKey,\n  bytesConcat,\n  encodeRawBytes,\n  decodeRawBytes,\n  encodeZarithInt,\n  encodeZarithUInt\n}","// @flow\n\nconst [genRandomBytes, deriveKeyByPBKDF2] = (() => {\n  if (process.env.NODE_ENV === 'browser') {\n    return [\n      (len : number) => window.crypto.getRandomValues(new Uint8Array(len)),\n      (password : string, salt : Uint8Array) =>\n        window.crypto.subtle.importKey(\n          'raw',\n          new TextEncoder().encode(password),\n          {\n            name: 'PBKDF2',\n          },\n          false, \n          ['deriveBits']\n        )\n        .then(key => {\n          return window.crypto.subtle.deriveBits(\n            {\n              name: 'PBKDF2',\n              salt: salt,\n              iterations: 32768,\n              hash: {name: 'SHA-512'}\n            },\n            key,\n            256 \n          )\n        })\n        .then(key => new Uint8Array(key))\n    ]\n  } else {\n    const crypto = require('crypto')\n    return [\n      crypto.randomBytes,\n      (passowrd : string, salt : Uint8Array) =>\n        new Promise<Uint8Array>((resolve, reject) => {\n          crypto.pbkdf2(passowrd, Buffer.from(salt), 32768, 32, 'sha512', (err, derived_key) => {\n            if (err) \n              reject(err)\n            else\n              resolve(derived_key)\n          })\n        })\n    ]\n  }\n})()\n\nimport bs58check from 'bs58check'\nimport bip39 from 'bip39'\nimport codec from './codec'\nimport elliptic from 'elliptic'\nimport blake from 'blakejs'\nimport { secretbox } from 'tweetnacl'\nimport nacl from 'tweetnacl'\n\nexport function blake2bHash(input : Uint8Array, len : number = 32) {\n  return blake.blake2b(input, null, len)\n}\n\nexport function genMnemonic(strength? : number) {\n  return bip39.generateMnemonic(strength)\n}\n\nexport class EncryptedBox {\n  encrypted : Uint8Array\n  prepared : Promise<void>\n\n  constructor(input : string = '', pwd : string = '') {\n    try {\n      codec.bs58checkPrefixPick(input)\n\n      const secret_key_bytes = bs58check.decode(input)\n\n      this.prepared = this.encrypt(secret_key_bytes, pwd)\n\n    } catch(_) {\n\n      this.encrypted = bs58check.decode(input)\n      this.prepared = Promise.resolve()\n\n    }\n  }\n\n  encrypt(bytes : Uint8Array, pwd : string = '') {\n    const password = genRandomBytes(8)\n    const salt = genRandomBytes(8)\n    return deriveKeyByPBKDF2(pwd + codec.toHex(password), salt)\n    .then(key => {\n      this.encrypted = codec.bytesConcat(\n        codec.bytesConcat(password, salt),\n        secretbox(bytes, new Uint8Array(24), key))\n    })\n  }\n\n  async show() {\n    await this.prepared\n    return bs58check.encode(Buffer.from(this.encrypted))\n  }\n\n  async reveal(pwd : string = '', new_pwd? : string) {\n    await this.prepared\n    \n    const password = this.encrypted.slice(0, 8)\n    const salt = this.encrypted.slice(8, 16)\n    const encrypted_msg = this.encrypted.slice(16)\n\n    const key = await deriveKeyByPBKDF2(pwd + codec.toHex(password), salt)\n    const decrypted_key = secretbox.open(encrypted_msg, new Uint8Array(24), key)\n\n    await this.encrypt(new Uint8Array(decrypted_key), new_pwd === undefined ? pwd : new_pwd)\n\n    if (decrypted_key)\n      return bs58check.encode(Buffer.from(decrypted_key))\n    else\n      throw 'Invalid password for revealing the key'\n  }\n\n  async revealKey(pwd : string = '', new_pwd? : string) {\n    const raw_key = await this.reveal(pwd, new_pwd)\n    const prefix = codec.bs58checkPrefixPick(raw_key)\n    \n    if (prefix.name === 'ed25519_seed')\n      return getKeyFromSeed(raw_key)\n    else\n      return getKeyFromSecretKey(raw_key)\n  }\n}\n\nclass Key {\n  name : string\n  secret_key : Uint8Array\n  pub_key : Uint8Array\n  address : string\n\n  constructor(name : 'ed25519' | 'secp256k1' | 'p256', secret_key : Uint8Array, pub_key : Uint8Array) {\n    this.name = name\n    this.secret_key = secret_key\n    this.pub_key = pub_key\n\n    this.address = {\n      ed25519: () => \n        codec.bs58checkEncode(blake2bHash(this.pub_key, 20), codec.prefix.ed25519_public_key_hash),\n      secp256k1: () => \n        codec.bs58checkEncode(blake2bHash(this.pub_key, 20), codec.prefix.secp256k1_public_key_hash),\n      p256: () => \n        codec.bs58checkEncode(blake2bHash(this.pub_key, 20), codec.prefix.p256_public_key_hash) \n    }[this.name]()\n  }\n\n  getSecretKey() {\n    return {\n      ed25519: () => \n        codec.bs58checkEncode(this.secret_key, codec.prefix.ed25519_secret_key),\n      secp256k1: () => \n        codec.bs58checkEncode(this.secret_key, codec.prefix.secp256k1_secret_key),\n      p256: () => \n        codec.bs58checkEncode(this.secret_key, codec.prefix.p256_secret_key)\n    }[this.name]()\n  }\n\n  getPublicKey() {\n    return {\n      ed25519: () => \n        codec.bs58checkEncode(this.pub_key, codec.prefix.ed25519_public_key),\n      secp256k1: () => \n        codec.bs58checkEncode(this.pub_key, codec.prefix.secp256k1_public_key),\n      p256: () => \n        codec.bs58checkEncode(this.pub_key, codec.prefix.p256_public_key)\n    }[this.name]()\n  }\n}\n\nfunction getKeyFromEd25519(input : Uint8Array) {\n  const ed25519 = new elliptic.eddsa('ed25519')\n  const key_pair = nacl.sign.keyPair[input.length === 32 ? 'fromSeed' : 'fromSecretKey'](input)\n  return new Key('ed25519', key_pair.secretKey, key_pair.publicKey)\n}\nfunction getKeyFromSecp256k1(key : Uint8Array) {\n  const key_pair = (new elliptic.ec('secp256k1')).keyFromPrivate(key)\n  const pub_key = new Uint8Array([2].concat(key_pair.getPublic().getX().toArray()))\n  return new Key('secp256k1', key, pub_key)\n}\nfunction getKeyFromP256(key : Uint8Array) {\n  const key_pair = (new elliptic.ec('p256')).keyFromPrivate(key)\n  const pub_key = new Uint8Array([3].concat(key_pair.getPublic().getX().toArray()))\n  return new Key('p256', key, pub_key)\n}\n \nexport async function decryptKey(encrypted : string, password : string) : Promise<Key> {\n  const prefix = codec.bs58checkPrefixPick(encrypted)\n  const encrypted_bytes = codec.bs58checkDecode(encrypted, prefix.bytes)\n  const salt = encrypted_bytes.slice(0, 8)\n  const encrypted_msg = encrypted_bytes.slice(8)\n  const key = await deriveKeyByPBKDF2(password, salt)\n  const result = secretbox.open(encrypted_msg, new Uint8Array(24), key)\n  const key_mapping = {\n    ed25519_encrypted_seed: getKeyFromEd25519,\n    secp256k1_encrypted_secret_key: getKeyFromSecp256k1,\n    p256_encrypted_secret_key: getKeyFromP256\n  }\n\n  if (prefix.name in key_mapping) {\n    return key_mapping[prefix.name](result)\n  } else {\n    throw 'No valid prefix for encrypted key found'\n  }\n}\n\nexport async function encryptKey(scheme : 'ed25519' | 'secp256k1' | 'p256', \n                           unencrypted : Uint8Array, \n                           password : string) : Promise<string> {\n  if (unencrypted.length !== 32) \n    throw `The length of key bytes to encrypt can only be 32. (should use seed for ed25519)`\n\n  const salt = genRandomBytes(8)\n  const key = await deriveKeyByPBKDF2(password, salt)\n  const encrypted_msg = secretbox(unencrypted, new Uint8Array(24), key)\n  const prefix_mapping = {\n    ed25519: codec.prefix.ed25519_encrypted_seed,\n    secp256k1: codec.prefix.secp256k1_encrypted_secret_key,\n    p256: codec.prefix.p256_encrypted_secret_key\n  }\n\n  const bytes = codec.bytesConcat(salt, encrypted_msg)\n  return codec.bs58checkEncode(bytes, prefix_mapping[scheme])\n}\n\nexport function getKeyFromSecretKey(sk: string) {\n  const prefix = codec.bs58checkPrefixPick(sk)\n  const bytes = codec.bs58checkDecode(sk, prefix.bytes)\n\n  const key_mapping = {\n    ed25519_secret_key: getKeyFromEd25519,\n    secp256k1_secret_key: getKeyFromSecp256k1,\n    p256_secret_key: getKeyFromP256\n  }\n\n  if (prefix.name in key_mapping) {\n    return key_mapping[prefix.name](bytes)\n  } else {\n    throw 'No valid prefix for secret key found'\n  }\n}\n\nexport function getKeyFromSeed(seed : string | Uint8Array) {\n  const seed_bytes = typeof seed === 'string' ? codec.bs58checkDecode(seed) : seed\n  const key_pair = nacl.sign.keyPair.fromSeed(seed_bytes)\n  return new Key('ed25519', key_pair.secretKey, key_pair.publicKey)\n}\n\nexport function getSeedFromWords(words : string | Array<string>, password? : string) {\n  const mnemonic = words instanceof Array ? words.join(' ') : words\n  return bip39.mnemonicToSeed(mnemonic, password).slice(0, 32)\n}\n\nexport function getKeyFromWords(words : string | Array<string>, password? : string) {\n  return getKeyFromSeed(getSeedFromWords(words, password))\n}\n\n\nexport function genRandomKey(scheme : 'ed25519' | 'secp256k1' | 'p256') {\n  const key_len = scheme === 'ed25519' ? 64 : 32\n  const key_mapping = {\n    ed25519: getKeyFromEd25519,\n    secp256k1: getKeyFromSecp256k1,\n    p256: getKeyFromP256\n  }\n\n  return key_mapping[scheme](genRandomBytes(key_len))\n}\n\nexport function signOperation(input_operation : Uint8Array | string, secret_key : string) {\n  const operation_bytes = typeof input_operation === 'string' ? codec.fromHex(input_operation) : input_operation\n  const marked_operation = codec.bytesConcat(codec.watermark.operation(), operation_bytes)\n  const operation_hash = blake2bHash(marked_operation)\n  const prefix = codec.bs58checkPrefixPick(secret_key)\n  const sig_mapping = {\n    ed25519_secret_key: codec.prefix.ed25519_signature,\n    secp256k1_secret_key: codec.prefix.secp256k1_signature,\n    p256_secret_key: codec.prefix.p256_signature\n  }\n\n  const secret_key_bytes = codec.bs58checkDecode(secret_key, prefix.bytes)\n  if (prefix.name in sig_mapping) {\n    const key = {\n      ed25519_secret_key: () => nacl.sign.keyPair.fromSecretKey(secret_key_bytes).secretKey,\n      secp256k1_secret_key: () => (new elliptic.ec('secp256k1')).keyFromPrivate(secret_key_bytes),\n      p256_secret_key: () => (new elliptic.ec('p256')).keyFromPrivate(secret_key_bytes)\n    }[prefix.name]()\n\n    const sig_bytes = prefix.name === 'ed25519_secret_key' ? \n      new Uint8Array(nacl.sign.detached(operation_hash, key)) :\n      (sig => new Uint8Array(sig.r.toArray().concat(sig.s.toArray())))(key.sign(operation_hash, {canonical: true})) \n\n    return codec.bs58checkEncode(sig_bytes, sig_mapping[prefix.name])\n  } else {\n    throw `invalid prefix for: ${secret_key}`\n  }\n}\n\nexport default {\n  EncryptedBox,\n  genMnemonic,\n  getKeyFromSeed,\n  getSeedFromWords,\n  getKeyFromWords,\n  genRandomKey,\n  genRandomBytes,\n  decryptKey,\n  encryptKey,\n  getKeyFromSecretKey,\n  signOperation\n}","// @flow\n\nimport BN from 'bn.js'\nimport codec from './codec'\n\n\nconst op_hex2bytes = {\n  transaction(op : Object) {\n    const result = ['08']\n  \n    result.push(codec.toTzBytes(op.source))\n\n    ;[op.fee, op.counter, op.gas_limit, op.storage_limit, op.amount].forEach(x => {\n      const hex = codec.encodeZarithUInt(x)\n      result.push(hex)\n    })\n\n    result.push(codec.toTzBytes(op.destination))\n\n    result.push(op.parameters ? 'FF' : '00')\n    if (op.parameters) {\n      const parameters = codec.encodeRawBytes(op.parameters)\n      result.push((parameters.length / 2).toString(16).padStart(8, '0'))\n      result.push(parameters)\n    }\n\n    return result.join('')\n  },\n  origination(op : Object) {\n    const result = ['09']\n\n    result.push(codec.toTzBytes(op.source))\n\n    ;[op.fee, op.counter, op.gas_limit, op.storage_limit].forEach(x => {\n      const hex = codec.encodeZarithUInt(x)\n      result.push(hex)\n    })\n\n    result.push(codec.toTzBytes(op.managerPubkey, true))\n\n    result.push(codec.encodeZarithUInt(op.balance))\n\n    result.push(op.spendable ? 'FF' : '00')\n    result.push(op.delegatable ? 'FF' : '00')\n    result.push(op.delegate ? 'FF' : '00')\n    if (op.delegate) {\n      result.push(codec.toTzBytes(op.delegate, true))\n    }\n\n    result.push(op.script ? 'FF' : '00')\n    if (op.script && op.script.code && op.script.storage) {\n      const code = codec.encodeRawBytes(op.script.code)\n      result.push((code.length / 2).toString(16).padStart(8, '0'))\n      result.push(code)\n\n      const storage = codec.encodeRawBytes(op.script.storage)\n      result.push((storage.length / 2).toString(16).padStart(8, '0'))\n      result.push(storage)\n    }\n\n    return result.join('')\n  },\n  delegation(op : Object) {\n    const result = ['10']\n\n    result.push(codec.toTzBytes(op.source))\n\n    ;[op.fee, op.counter, op.gas_limit, op.storage_limit].forEach(x => {\n      const hex = codec.encodeZarithUInt(x)\n      result.push(hex)\n    })\n\n    result.push(op.delegate ? 'FF' : '00')\n    if (op.delegate) {\n      result.push(codec.toTzBytes(op.delegate, true))\n    }\n\n    return result.join('')\n  },\n  reveal(op : Object) {\n    const result = ['07']\n\n    result.push(codec.toTzBytes(op.source))\n\n    ;[op.fee, op.counter, op.gas_limit, op.storage_limit].forEach(x => {\n      const hex = codec.encodeZarithUInt(x)\n      result.push(hex)\n    })\n\n    result.push(codec.toTzBytes(op.public_key, true))\n\n    return result.join('')\n  }\n}\n\nexport function forgeOperation(contents : Array<Object>, branch : string) {\n  const branch_bytes = codec.bs58checkDecode(branch)\n  const result = [codec.toHex(branch_bytes)]\n\n  contents.forEach(op => {\n    if (!op_hex2bytes[op.kind])\n      throw `Only support reveal(07), transaction(08), origination(09) and delegation(10) operations.\\nBut current operation is ${op.kind}`\n\n    const op_hex = op_hex2bytes[op.kind](op)\n    result.push(op_hex)\n  })\n\n  return result.join('').toLowerCase()\n}\n\nexport function parseOperationBytes(input : string) {\n  input = input.slice(64).toUpperCase()\n\n  let index = 0\n\n  const read = len => {\n    const result = input.slice(index, len ? index + len : undefined)\n    index += len\n    return result\n  }\n\n  const readUInt = () => {\n    const first_bytes = parseInt(read(2), 16).toString(2).padStart(8, '0')\n    const valid_bytes = [first_bytes.slice(1)]\n\n    let checknext = first_bytes[0] === '1'\n    while (checknext) {\n      const bytes = parseInt(read(2), 16).toString(2).padStart(8, '0')\n\n      valid_bytes.push(bytes.slice(1))\n      checknext = bytes[0] === '1'\n    }\n\n    const num = new BN(valid_bytes.reverse().join(''), 2)\n    return num.toString(10)\n  }\n\n  const output = []\n  while(index < input.length - 1) {\n    const op_tag = read(2)\n\n    if (op_tag === '07') {\n      const source = codec.toTzStrValue(read(44))\n      const fee = readUInt()\n      const counter = readUInt()\n      const gas_limit = readUInt()\n      const storage_limit = readUInt()\n      const public_key = codec.toTzStrValue(read())\n\n      output.push({\n        kind: 'reveal',\n        source,\n        fee,\n        counter,\n        gas_limit,\n        storage_limit,\n        public_key\n      })\n\n    } else if (op_tag === '08') {\n      const source = codec.toTzStrValue(read(44))\n      const fee = readUInt()\n      const counter = readUInt()\n      const gas_limit = readUInt()\n      const storage_limit = readUInt()\n      const amount = readUInt()\n      const destination = codec.toTzStrValue(read(44))\n      let parameters\n      if (read(2) === 'FF') {\n        const len = parseInt(read(8), 16) * 2\n        parameters = codec.decodeRawBytes(read(len))\n      }\n\n      output.push({\n        kind: 'transaction',\n        source,\n        fee,\n        counter,\n        gas_limit,\n        storage_limit,\n        amount,\n        destination,\n        parameters\n      })\n    } else if (op_tag === '09') {\n      const source = codec.toTzStrValue(read(44))\n      const fee = readUInt()\n      const counter = readUInt()\n      const gas_limit = readUInt()\n      const storage_limit = readUInt()\n      const managerPubkey = codec.toTzStrValue(read(42))\n      const balance = readUInt()\n      const spendable = read(2) === '00' ? false : true\n      const delegatable = read(2) === '00' ? false : true\n      const delegate = read(2) === '00' ? undefined : codec.toTzStrValue(read(42))\n      let script\n      if (read(2) === 'FF') {\n        const code_len = parseInt(read(8), 16) * 2\n        const code = codec.decodeRawBytes(read(code_len))\n\n        const storage_len = parseInt(read(8), 16) * 2\n        const storage = codec.decodeRawBytes(read(storage_len))\n        script = {code, storage}\n      }\n\n      output.push({\n        kind: 'origination',\n        source,\n        fee,\n        counter,\n        gas_limit,\n        storage_limit,\n        managerPubkey,\n        balance,\n        spendable,\n        delegatable,\n        delegate,\n        script\n      })\n    } else if (op_tag === '10') {\n\n      const source = codec.toTzStrValue(read(44))\n      const fee = readUInt()\n      const counter = readUInt()\n      const gas_limit = readUInt()\n      const storage_limit = readUInt()\n      const delegate = read(2) === '00' ? undefined : codec.toTzStrValue(read(42))\n\n      output.push({\n        kind: 'delegation',\n        source,\n        fee,\n        counter,\n        gas_limit,\n        storage_limit,\n        delegate\n      })\n\n    } else {\n      throw `Only support reveal(07), transaction(08), origination(09) and delegation(10) tags.\\nBut current tag is ${op_tag} at index: ${index}`\n    }\n\n  }\n\n  return output\n}\n\nexport default {\n  forgeOperation,\n  parseOperationBytes\n}","// @flow\n\nimport PsddFKi3_codec from './PsddFKi3/codec'\nimport PsddFKi3_crypto from './PsddFKi3/crypto'\nimport PsddFKi3_localop from './PsddFKi3/localop'\n\nconst protocol_mapping = {\n  PsddFKi3: {\n    codec: PsddFKi3_codec,\n    crypto: PsddFKi3_crypto,\n    localop: PsddFKi3_localop\n  }\n}\n\nconst export_fns = {\n  codec: protocol_mapping.PsddFKi3.codec,\n  crypto: protocol_mapping.PsddFKi3.crypto,\n  localop: protocol_mapping.PsddFKi3.localop,\n  \n  modProtocol(protocol : string) {\n    if (protocol in protocol_mapping) {\n      export_fns.codec = protocol_mapping[protocol].codec\n      export_fns.crypto = protocol_mapping[protocol].crypto\n      export_fns.localop = protocol_mapping[protocol].localop\n    } else {\n      throw `Protocol:${protocol} doesn't exist in protocols`\n    }\n  }\n}\n\nexport default export_fns"]}