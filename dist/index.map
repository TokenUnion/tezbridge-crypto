{"version":3,"sources":["codec.js","index.js"],"names":["prefix","block_hash","Uint8Array","operation_hash","operation_list_hash","operation_list_list_hash","protocol_hash","context_hash","ed25519_public_key_hash","secp256k1_public_key_hash","p256_public_key_hash","cryptobox_public_key_hash","ed25519_seed","ed25519_public_key","secp256k1_secret_key","p256_secret_key","ed25519_encrypted_seed","secp256k1_encrypted_secret_key","p256_encrypted_secret_key","secp256k1_public_key","p256_public_key","secp256k1_scalar","secp256k1_element","ed25519_secret_key","ed25519_signature","secp256k1_signature","p256_signature","generic_signature","chain_id","op_mapping","prim_mapping","name","len","annot","decodeBytes","bytes","toUpperCase","index","read","slice","walk","b","prim","Object","op","args","Array","apply","map","int_len","parseInt","data","match_result","match","string_raw","x","string","TextDecoder","decode","first_bytes","toString","padStart","checknext","is_positive","valid_bytes","push","int","reverse","join","limit","seq_lst","codec"],"mappings":";AAiQC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,EAAA,QAAA,YAAA,EA7PM,IAAMA,EAAS,CACpBC,WAAY,IAAIC,WAAW,CAAC,EAAG,KAC/BC,eAAgB,IAAID,WAAW,CAAC,EAAG,MACnCE,oBAAqB,IAAIF,WAAW,CAAC,IAAK,MAC1CG,yBAA0B,IAAIH,WAAW,CAAC,GAAI,IAAK,MACnDI,cAAe,IAAIJ,WAAW,CAAC,EAAG,MAClCK,aAAc,IAAIL,WAAW,CAAC,GAAI,MAElCM,wBAAyB,IAAIN,WAAW,CAAC,EAAG,IAAK,MACjDO,0BAA2B,IAAIP,WAAW,CAAC,EAAG,IAAK,MACnDQ,qBAAsB,IAAIR,WAAW,CAAC,EAAG,IAAK,MAE9CS,0BAA2B,IAAIT,WAAW,CAAC,IAAK,MAEhDU,aAAc,IAAIV,WAAW,CAAC,GAAI,GAAI,GAAI,IAC1CW,mBAAoB,IAAIX,WAAW,CAAC,GAAI,GAAI,GAAI,MAChDY,qBAAsB,IAAIZ,WAAW,CAAC,GAAI,IAAK,IAAK,MACpDa,gBAAiB,IAAIb,WAAW,CAAC,GAAI,GAAI,IAAK,MAE9Cc,uBAAwB,IAAId,WAAW,CAAC,EAAG,GAAI,GAAI,IAAK,KACxDe,+BAAgC,IAAIf,WAAW,CAAC,EAAG,IAAK,IAAK,IAAK,MAClEgB,0BAA2B,IAAIhB,WAAW,CAAC,EAAG,GAAI,GAAI,IAAK,MAE3DiB,qBAAsB,IAAIjB,WAAW,CAAC,EAAG,IAAK,IAAK,KACnDkB,gBAAiB,IAAIlB,WAAW,CAAC,EAAG,IAAK,IAAK,MAC9CmB,iBAAkB,IAAInB,WAAW,CAAC,GAAI,IAAK,MAC3CoB,kBAAmB,IAAIpB,WAAW,CAAC,EAAG,GAAI,IAE1CqB,mBAAoB,IAAIrB,WAAW,CAAC,GAAI,IAAK,GAAI,IACjDsB,kBAAmB,IAAItB,WAAW,CAAC,EAAG,IAAK,IAAK,IAAK,KACrDuB,oBAAqB,IAAIvB,WAAW,CAAC,GAAI,IAAK,IAAK,GAAI,KACvDwB,eAAgB,IAAIxB,WAAW,CAAC,GAAI,IAAK,GAAI,KAC7CyB,kBAAmB,IAAIzB,WAAW,CAAC,EAAG,IAAK,KAE3C0B,SAAU,IAAI1B,WAAW,CAAC,EAAG,GAAI,KA2NlC,QAAA,OAAA,EAxND,IAAM2B,EAAa,CACZ,KAAA,YACA,KAAA,UACA,KAAA,OACA,KAAA,QACA,KAAA,MACA,KAAA,OACA,KAAA,OACA,KAAA,OACA,KAAA,QACA,KAAA,OACA,KAAA,OACA,KAAA,OACA,KAAA,OACA,KAAA,SACA,KAAA,UACA,KAAA,SACA,GAAA,SACA,GAAA,MACA,GAAA,MACA,GAAA,SACA,GAAA,MACA,GAAA,UACA,GAAA,MACA,GAAA,MACA,GAAA,kBACA,GAAA,UACA,KAAA,SACA,KAAA,OACA,KAAA,iBACA,KAAA,kBACA,KAAA,mBACA,KAAA,MACA,GAAA,OACA,GAAA,MACA,GAAA,OACA,GAAA,YACA,GAAA,YACA,GAAA,KACA,GAAA,OACA,GAAA,WACA,GAAA,KACA,GAAA,MACA,KAAA,KACA,KAAA,WACA,KAAA,KACA,KAAA,UACA,KAAA,UACA,KAAA,UACA,GAAA,MACA,GAAA,SACA,GAAA,KACA,GAAA,OACA,GAAA,OACA,GAAA,MACA,GAAA,MACA,GAAA,KACA,GAAA,MACA,GAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,OACA,KAAA,MACA,GAAA,MACA,GAAA,KACA,GAAA,OACA,GAAA,OACA,GAAA,QACA,GAAA,OACA,GAAA,OACA,GAAA,SACA,GAAA,SACA,GAAA,OACA,KAAA,iBACA,KAAA,MACA,KAAA,OACA,KAAA,kBACA,KAAA,eACA,KAAA,OACA,GAAA,SACA,GAAA,MACA,GAAA,OACA,GAAA,YACA,GAAA,UACA,GAAA,WACA,GAAA,QACA,GAAA,OACA,GAAA,SACA,GAAA,OACA,KAAA,WACA,KAAA,MACA,KAAA,MACA,KAAA,WACA,KAAA,SACA,KAAA,OACA,GAAA,MACA,GAAA,UACA,GAAA,MACA,GAAA,SACA,GAAA,KACA,GAAA,OACA,GAAA,MACA,GAAA,YACA,GAAA,SACA,GAAA,QACA,KAAA,QACA,KAAA,YACA,KAAA,OACA,KAAA,YACA,KAAA,UACA,KAAA,SAGDC,EAAe,CACb,KAAA,MACA,KAAA,SACA,KAAA,MACA,KAAA,CAACC,KAAM,OAAQC,IAAK,EAAGC,OAAO,GAC9B,KAAA,CAACF,KAAM,OAAQC,IAAK,EAAGC,OAAO,GAC9B,KAAA,CAACF,KAAM,OAAQC,IAAK,EAAGC,OAAO,GAC9B,KAAA,CAACF,KAAM,OAAQC,IAAK,EAAGC,OAAO,GAC9B,KAAA,CAACF,KAAM,OAAQC,IAAK,EAAGC,OAAO,GAC9B,KAAA,CAACF,KAAM,OAAQC,IAAK,EAAGC,OAAO,GAC9B,KAAA,CAACF,KAAM,OAAQC,IAAK,EAAGC,OAAO,GAC9B,KAAA,SAGD,SAASC,EAAYC,GAC1BA,EAAQA,EAAMC,cAEVC,IAAAA,EAAQ,EAENC,EAAO,SAAAN,GAAOG,OAAAA,EAAMI,MAAMF,EAAOA,EAAQL,IAiFxCQ,OA/EM,SAAPA,IACEC,IAAAA,EAAIH,EAAK,GACTI,EAAOZ,EAAaW,GAEtBC,GAAAA,aAAgBC,OAAQ,CAE1BN,GAAS,EACHO,IAAAA,EAAKf,EAAWS,EAAK,IAIpB,OAHPD,GAAS,EAGF,CAACK,KAAME,EAAIC,KADLC,MAAMC,MAAM,KAAM,IAAID,MAAMJ,EAAKV,MACjBgB,IAAI,WAAMR,OAAAA,OAGnCC,GAAM,OAANA,EAAY,CAEdJ,GAAS,EACHL,IAAAA,EAAMM,EAAK,GACjBD,GAAS,EACHY,IAAAA,EAA8B,EAApBC,SAASlB,EAAK,IACxBmB,EAAOb,EAAKW,GAEX,OADPZ,GAASY,EACF,CAACd,MAAOgB,GAEV,GAAU,OAANV,EAAY,CACrBJ,GAAS,EACHL,IAAAA,EAAMM,EAAK,GACjBD,GAAS,EACHY,IAAAA,EAA8B,EAApBC,SAASlB,EAAK,IACxBmB,EAAOb,EAAKW,GAClBZ,GAASY,EAEHG,IAAAA,EAAeD,EAAKE,MAAM,eAC5BD,GAAAA,aAAwBN,MAAO,CAC3BQ,IAAAA,EAAa,IAAIpD,WAAWkD,EAAaJ,IAAI,SAAAO,GAAKL,OAAAA,SAASK,EAAG,OAC7D,MAAA,CAACC,OAAQ,IAAIC,YAAY,SAASC,OAAOJ,IAE1C,KAAA,oBAGH,GAAU,OAANb,EAAY,CACrBJ,GAAS,EAEHsB,IAAAA,EAAcT,SAASZ,EAAK,GAAI,IAAIsB,SAAS,GAAGC,SAAS,EAAG,KAClExB,GAAS,EACWsB,EAAY,GAKzBG,IALDC,IAEAC,EAAc,CAACL,EAAYpB,MAAM,IAEnCuB,EAA+B,MAAnBH,EAAY,GACrBG,GAAW,CACV3B,IAAAA,EAAQe,SAASZ,EAAK,GAAI,IAAIsB,SAAS,GAAGC,SAAS,EAAG,KAC5DxB,GAAS,EAET2B,EAAYC,KAAK9B,EAAMI,MAAM,IAC7BuB,EAAyB,MAAb3B,EAAM,GAGb,MAAA,CAAC+B,IAAKhB,SAASc,EAAYG,UAAUC,KAAK,IAAK,GAAGR,YACpD,GAAU,OAANnB,EAAY,CACrBJ,GAAS,EAEHL,IAAAA,EAAMM,EAAK,GACjBD,GAAS,EAMFgC,IALDpB,IAAAA,EAA8B,EAApBC,SAASlB,EAAK,IAExBqC,GADO/B,EAAKW,GACJZ,EAAQY,GAEhBqB,EAAU,GACTD,EAAQhC,GACbiC,EAAQL,KAAKzB,KAER8B,OAAAA,GAON9B;;AC5PM,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAFf,IAAA,EAAA,QAAA,WAEe,EAAA,CACb+B,MAAO,CAAErC,YAAAA,EAAAA,cADI,QAAA,QAAA","file":"index.map","sourceRoot":"../src","sourcesContent":["// @flow\n\nimport type { TezJSON } from './types'\n\nexport const prefix = {\n  block_hash: new Uint8Array([1, 52]), // B(51)\n  operation_hash: new Uint8Array([5, 116]), // o(51)\n  operation_list_hash: new Uint8Array([133, 233]), // Lo(52)\n  operation_list_list_hash: new Uint8Array([29, 159, 109]), // LLo(53)\n  protocol_hash: new Uint8Array([2, 170]), // P(51)\n  context_hash: new Uint8Array([79, 199]), // Co(52)\n\n  ed25519_public_key_hash: new Uint8Array([6, 161, 159]), // tz1(36)\n  secp256k1_public_key_hash: new Uint8Array([6, 161, 161]), // tz2(36)\n  p256_public_key_hash: new Uint8Array([6, 161, 164]), // tz3(36)\n\n  cryptobox_public_key_hash: new Uint8Array([153, 103]), // id(30)\n\n  ed25519_seed: new Uint8Array([13, 15, 58, 7]), // edsk(54)\n  ed25519_public_key: new Uint8Array([13, 15, 37, 217]), // edpk(54)\n  secp256k1_secret_key: new Uint8Array([17, 162, 224, 201]), // spsk(54)\n  p256_secret_key: new Uint8Array([16, 81, 238, 189]), // p2sk(54)\n\n  ed25519_encrypted_seed: new Uint8Array([7, 90, 60, 179, 41]), // edesk(88)\n  secp256k1_encrypted_secret_key: new Uint8Array([9, 237, 241, 174, 150]), // spesk(88)\n  p256_encrypted_secret_key: new Uint8Array([9, 48, 57, 115, 171]), // p2esk(88)\n\n  secp256k1_public_key: new Uint8Array([3, 254, 226, 86]), // sppk(55)\n  p256_public_key: new Uint8Array([3, 178, 139, 127]), // p2pk(55)\n  secp256k1_scalar: new Uint8Array([38, 248, 136]), // SSp(53)\n  secp256k1_element: new Uint8Array([5, 92, 0]), // GSp(54)\n\n  ed25519_secret_key: new Uint8Array([43, 246, 78, 7]), // edsk(98)\n  ed25519_signature: new Uint8Array([9, 245, 205, 134, 18]), // edsig(99)\n  secp256k1_signature: new Uint8Array([13, 115, 101, 19, 63]), // spsig1(99)\n  p256_signature: new Uint8Array([54, 240, 44, 52]), // p2sig(98)\n  generic_signature: new Uint8Array([4, 130, 43]), // sig(96)\n\n  chain_id: new Uint8Array([7, 82, 0]) // Net(15)\n}\n\nconst op_mapping = {\n  '00':'parameter',\n  '01':'storage',\n  '02':'code',\n  '03':'False',\n  '04':'Elt',\n  '05':'Left',\n  '06':'None',\n  '07':'Pair',\n  '08':'Right',\n  '09':'Some',\n  '0A':'True',\n  '0B':'Unit',\n  '0C':'PACK',\n  '0D':'UNPACK',\n  '0E':'BLAKE2B',\n  '0F':'SHA256',\n  '10':'SHA512',\n  '11':'ABS',\n  '12':'ADD',\n  '13':'AMOUNT',\n  '14':'AND',\n  '15':'BALANCE',\n  '16':'CAR',\n  '17':'CDR',\n  '18':'CHECK_SIGNATURE',\n  '19':'COMPARE',\n  '1A':'CONCAT',\n  '1B':'CONS',\n  '1C':'CREATE_ACCOUNT',\n  '1D':'CREATE_CONTRACT',\n  '1E':'IMPLICIT_ACCOUNT',\n  '1F':'DIP',\n  '20':'DROP',\n  '21':'DUP',\n  '22':'EDIV',\n  '23':'EMPTY_MAP',\n  '24':'EMPTY_SET',\n  '25':'EQ',\n  '26':'EXEC',\n  '27':'FAILWITH',\n  '28':'GE',\n  '29':'GET',\n  '2A':'GT',\n  '2B':'HASH_KEY',\n  '2C':'IF',\n  '2D':'IF_CONS',\n  '2E':'IF_LEFT',\n  '2F':'IF_NONE',\n  '30':'INT',\n  '31':'LAMBDA',\n  '32':'LE',\n  '33':'LEFT',\n  '34':'LOOP',\n  '35':'LSL',\n  '36':'LSR',\n  '37':'LT',\n  '38':'MAP',\n  '39':'MEM',\n  '3A':'MUL',\n  '3B':'NEG',\n  '3C':'NEQ',\n  '3D':'NIL',\n  '3E':'NONE',\n  '3F':'NOT',\n  '40':'NOW',\n  '41':'OR',\n  '42':'PAIR',\n  '43':'PUSH',\n  '44':'RIGHT',\n  '45':'SIZE',\n  '46':'SOME',\n  '47':'SOURCE',\n  '48':'SENDER',\n  '49':'SELF',\n  '4A':'STEPS_TO_QUOTA',\n  '4B':'SUB',\n  '4C':'SWAP',\n  '4D':'TRANSFER_TOKENS',\n  '4E':'SET_DELEGATE',\n  '4F':'UNIT',\n  '50':'UPDATE',\n  '51':'XOR',\n  '52':'ITER',\n  '53':'LOOP_LEFT',\n  '54':'ADDRESS',\n  '55':'CONTRACT',\n  '56':'ISNAT',\n  '57':'CAST',\n  '58':'RENAME',\n  '59':'bool',\n  '5A':'contract',\n  '5B':'int',\n  '5C':'key',\n  '5D':'key_hash',\n  '5E':'lambda',\n  '5F':'list',\n  '60':'map',\n  '61':'big_map',\n  '62':'nat',\n  '63':'option',\n  '64':'or',\n  '65':'pair',\n  '66':'set',\n  '67':'signature',\n  '68':'string',\n  '69':'bytes',\n  '6A':'mutez',\n  '6B':'timestamp',\n  '6C':'unit',\n  '6D':'operation',\n  '6E':'address',\n  '6F':'SLICE',\n}\n\nconst prim_mapping = {\n  '00': 'int',    \n  '01': 'string',             \n  '02': 'seq',             \n  '03': {name: 'prim', len: 0, annot: false},          \n  '04': {name: 'prim', len: 0, annot: true},\n  '05': {name: 'prim', len: 1, annot: false},           \n  '06': {name: 'prim', len: 1, annot: true},   \n  '07': {name: 'prim', len: 2, annot: false},          \n  '08': {name: 'prim', len: 2, annot: true},  \n  '09': {name: 'prim', len: 3, annot: true},\n  '0A': 'bytes'                  \n}\n\nexport function decodeBytes(bytes : string) : TezJSON {\n  bytes = bytes.toUpperCase()\n  \n  let index = 0\n\n  const read = len => bytes.slice(index, index + len)\n\n  const walk = () => {\n    const b = read(2)\n    const prim = prim_mapping[b]\n    \n    if (prim instanceof Object) {\n\n      index += 2\n      const op = op_mapping[read(2)]\n      index += 2\n\n      const args = Array.apply(null, new Array(prim.len))\n      return {prim: op, args: args.map(() => walk())}\n\n    } else {\n      if (b === '0A') {\n\n        index += 2\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        index += int_len\n        return {bytes: data}\n\n      } else if (b === '01') {\n        index += 2\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        index += int_len\n\n        const match_result = data.match(/[\\dA-F]{2}/g)\n        if (match_result instanceof Array) {\n          const string_raw = new Uint8Array(match_result.map(x => parseInt(x, 16)))\n          return {string: new TextDecoder('utf-8').decode(string_raw)}\n        } else {\n          throw \"Input bytes error\"\n        }\n\n      } else if (b === '00') {\n        index += 2\n\n        const first_bytes = parseInt(read(2), 16).toString(2).padStart(8, '0')\n        index += 2\n        const is_positive = first_bytes[1] === '0'\n\n        const valid_bytes = [first_bytes.slice(2)]\n\n        let checknext = first_bytes[0] === '1'\n        while (checknext) {\n          const bytes = parseInt(read(2), 16).toString(2).padStart(8, '0')\n          index += 2\n\n          valid_bytes.push(bytes.slice(1))\n          checknext = bytes[0] === '1'\n        }\n\n        return {int: parseInt(valid_bytes.reverse().join(''), 2).toString()}\n      } else if (b === '02') {\n        index += 2\n\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        const limit = index + int_len\n\n        const seq_lst = []\n        while (limit > index) {\n          seq_lst.push(walk())\n        }\n        return seq_lst\n      }\n\n    }\n\n  }\n\n  return walk()\n}\n\n","// @flow\n\nimport { decodeBytes } from './codec'\n\nexport default {\n  codec: { decodeBytes }\n}"]}