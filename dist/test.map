{"version":3,"sources":["codec.js","crypto.js","../src/index.js","util.js","index.js"],"names":["bytesConcat","x","y","tmp","Uint8Array","length","set","bs58checkEncode","input","prefix","bs58check","encode","bs58checkDecode","decode","slice","bs58checkPrefixPick","bytes","block_hash","operation_hash","operation_list_hash","operation_list_list_hash","protocol_hash","context_hash","ed25519_public_key_hash","secp256k1_public_key_hash","p256_public_key_hash","cryptobox_public_key_hash","ed25519_seed","ed25519_public_key","secp256k1_secret_key","p256_secret_key","ed25519_encrypted_seed","secp256k1_encrypted_secret_key","p256_encrypted_secret_key","secp256k1_public_key","p256_public_key","secp256k1_scalar","secp256k1_element","ed25519_secret_key","ed25519_signature","secp256k1_signature","p256_signature","generic_signature","chain_id","contract_hash","prefix_mapping","matched_mapping","Net","id","tz1","tz2","tz3","KT1","B","o","P","Lo","Co","LLo","SSp","edsk","edpk","spsk","p2sk","GSp","sppk","p2pk","edesk","spesk","p2esk","sig","p2sig","edsig","spsig1","key","len","name","getContractHexKey","contract","hex","elliptic","utils","toHex","hex_key","undefined","map","join","watermark","block_header","endorsement","operation","custom","op_mapping","prim_mapping","annot","encodeRawBytes","result","Array","Object","push","toString","padStart","int","decodeRawBytes","toUpperCase","index","read","walk","b","prim","op","args","apply","int_len","parseInt","data","match_result","match","string_raw","string","TextDecoder","first_bytes","is_positive","valid_bytes","checknext","BigNumber","reverse","limit","seq_lst","blake2bHash","blake","blake2b","getMnemonic","strength","bip39","generateMnemonic","Key","constructor","secret_key","pub_key","address","ed25519","codec","secp256k1","p256","getSecretKey","getPublicKey","decryptKey","encrypted","password","encrypted_bytes","salt","encrypted_msg","crypto","pbkdf2Sync","secretbox","open","key_mapping","seed","eddsa","key_pair","nacl","sign","keyPair","fromSeed","secretKey","publicKey","ec","keyFromPrivate","concat","getPublic","getX","toArray","getKeyFromSeed","seed_bytes","getKeyFromWords","words","mnemonic","mnemonicToSeed","signOperation","operation_bytes","marked_operation","sig_mapping","secret_key_bytes","keyFromSecret","sig_bytes","toBytes","r","s","assert","v","m","ok","console","log","TBC","TezBridgeCrypto","fn_tests","answer","JSON","stringify","a1","a2","a3","source","bytes_auto","str","words12","split","words18","words24","edsig_prefix","spsig1_prefix","p2sig_prefix","main"],"mappings":";AA2Ye,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,EAAA,QAAA,gBAAA,EAAA,QAAA,gBAAA,EAAA,QAAA,oBAAA,EAAA,QAAA,kBAAA,EAAA,QAAA,eAAA,EAAA,QAAA,eAAA,EAAA,QAAA,QAAA,QAAA,UAAA,QAAA,YAAA,EAzYf,IAAA,EAAA,QAAA,gBACA,EAAA,EAAA,QAAA,cACA,EAAA,EAAA,QAAA,aAuYe,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAnYR,SAASA,EAAYC,EAAgBC,GACpCC,MAAAA,EAAM,IAAIC,WAAWH,EAAEI,OAASH,EAAEG,QAGjCF,OAFPA,EAAIG,IAAIL,EAAG,GACXE,EAAIG,IAAIJ,EAAGD,EAAEI,QACNF,EAGF,SAASI,EAAgBC,EAAoBC,GAC3CC,OAAAA,EAAUC,QAAAA,OAAOX,EAAYS,EAAQD,IAGvC,SAASI,EAAgBJ,EAAgBC,GACvCC,OAAAA,EAAUG,QAAAA,OAAOL,GAAOM,MAAML,EAASA,EAAOJ,OAASU,EAAoBP,GAAOQ,MAAMX,QAG1F,MAAMI,EAAS,CACpBQ,WAAY,IAAIb,WAAW,CAAC,EAAG,KAC/Bc,eAAgB,IAAId,WAAW,CAAC,EAAG,MACnCe,oBAAqB,IAAIf,WAAW,CAAC,IAAK,MAC1CgB,yBAA0B,IAAIhB,WAAW,CAAC,GAAI,IAAK,MACnDiB,cAAe,IAAIjB,WAAW,CAAC,EAAG,MAClCkB,aAAc,IAAIlB,WAAW,CAAC,GAAI,MAElCmB,wBAAyB,IAAInB,WAAW,CAAC,EAAG,IAAK,MACjDoB,0BAA2B,IAAIpB,WAAW,CAAC,EAAG,IAAK,MACnDqB,qBAAsB,IAAIrB,WAAW,CAAC,EAAG,IAAK,MAE9CsB,0BAA2B,IAAItB,WAAW,CAAC,IAAK,MAEhDuB,aAAc,IAAIvB,WAAW,CAAC,GAAI,GAAI,GAAI,IAC1CwB,mBAAoB,IAAIxB,WAAW,CAAC,GAAI,GAAI,GAAI,MAChDyB,qBAAsB,IAAIzB,WAAW,CAAC,GAAI,IAAK,IAAK,MACpD0B,gBAAiB,IAAI1B,WAAW,CAAC,GAAI,GAAI,IAAK,MAE9C2B,uBAAwB,IAAI3B,WAAW,CAAC,EAAG,GAAI,GAAI,IAAK,KACxD4B,+BAAgC,IAAI5B,WAAW,CAAC,EAAG,IAAK,IAAK,IAAK,MAClE6B,0BAA2B,IAAI7B,WAAW,CAAC,EAAG,GAAI,GAAI,IAAK,MAE3D8B,qBAAsB,IAAI9B,WAAW,CAAC,EAAG,IAAK,IAAK,KACnD+B,gBAAiB,IAAI/B,WAAW,CAAC,EAAG,IAAK,IAAK,MAC9CgC,iBAAkB,IAAIhC,WAAW,CAAC,GAAI,IAAK,MAC3CiC,kBAAmB,IAAIjC,WAAW,CAAC,EAAG,GAAI,IAE1CkC,mBAAoB,IAAIlC,WAAW,CAAC,GAAI,IAAK,GAAI,IACjDmC,kBAAmB,IAAInC,WAAW,CAAC,EAAG,IAAK,IAAK,IAAK,KACrDoC,oBAAqB,IAAIpC,WAAW,CAAC,GAAI,IAAK,IAAK,GAAI,KACvDqC,eAAgB,IAAIrC,WAAW,CAAC,GAAI,IAAK,GAAI,KAC7CsC,kBAAmB,IAAItC,WAAW,CAAC,EAAG,IAAK,KAE3CuC,SAAU,IAAIvC,WAAW,CAAC,EAAG,GAAI,IAEjCwC,cAAe,IAAIxC,WAAW,CAAC,EAAG,GAAI,OAGjC,SAASW,EAAoBP,GAC5BqC,MAuDAC,EAvDiB,CACpB,GAAK,CACJC,IAAK,YAEN,GAAK,CACJC,GAAI,6BAEL,GAAK,CACJC,IAAK,0BACLC,IAAK,4BACLC,IAAK,uBACLC,IAAK,iBAEN,GAAK,CACJC,EAAG,aACHC,EAAG,iBACHC,EAAG,iBAEJ,GAAK,CACJC,GAAI,sBACJC,GAAI,gBAEL,GAAK,CACJC,IAAK,2BACLC,IAAK,oBAEN,GAAK,CACJC,KAAM,eACNC,KAAM,qBACNC,KAAM,uBACNC,KAAM,kBACNC,IAAK,qBAEN,GAAK,CACJC,KAAM,uBACNC,KAAM,mBAEP,GAAK,CACJC,MAAO,yBACPC,MAAO,iCACPC,MAAO,6BAER,GAAK,CACJC,IAAK,qBAEN,GAAK,CACJV,KAAM,qBACNW,MAAO,kBAER,GAAK,CACJC,MAAO,oBACPC,OAAQ,wBAI2BjE,EAAMH,QACzCyC,GAAAA,EACG,IAAA,MAAM4B,KAAO5B,EAAiB,CAC3B6B,MAAAA,EAAMD,EAAIrE,OACZG,GAAAA,EAAMM,MAAM,EAAG6D,KAASD,EAC1B,MAAO,CAAC1D,MAAOP,EAAOqC,EAAgB4B,IAAOE,KAAK9B,EAAgB4B,IAIjE,6BAAuBlE,IAGzB,SAASqE,EAAkBC,GAC5BA,GAAoB,KAApBA,EAASzE,QAA0C,QAAzByE,EAAShE,MAAM,EAAG,GAC9C,0BAA2BgE,IAEvB9D,MAAAA,EAAQJ,EAAgBkE,EAAUrE,EAAOmC,eACzCmC,EAAMC,EAASC,QAAAA,MAAMC,MAAMlE,GAG1BmE,MAFS,CAAC,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,IAAK,CAAC,QAAGC,IAAYC,IAAIpF,GAAK8E,EAAIjE,MAAMb,EAAE,GAAIA,EAAE,KAAKqF,KAAK,KAmQ7F,QAAA,OAAA,EA9PR,MAAMC,EAAY,CACvBC,aAAa7C,GACJ3C,EAAY,IAAII,WAAW,CAAC,IAAKuC,GAE1C8C,YAAY9C,GACH3C,EAAY,IAAII,WAAW,CAAC,IAAKuC,GAE1C+C,UAAS,IACA,IAAItF,WAAW,CAAC,IAEzBuF,OAAO1F,GACEA,GAmPI,QAAA,UAAA,EA/Of,MAAM2F,EAAa,CACZ,KAAA,YACA,KAAA,UACA,KAAA,OACA,KAAA,QACA,KAAA,MACA,KAAA,OACA,KAAA,OACA,KAAA,OACA,KAAA,QACA,KAAA,OACA,KAAA,OACA,KAAA,OACA,KAAA,OACA,KAAA,SACA,KAAA,UACA,KAAA,SACA,GAAA,SACA,GAAA,MACA,GAAA,MACA,GAAA,SACA,GAAA,MACA,GAAA,UACA,GAAA,MACA,GAAA,MACA,GAAA,kBACA,GAAA,UACA,KAAA,SACA,KAAA,OACA,KAAA,iBACA,KAAA,kBACA,KAAA,mBACA,KAAA,MACA,GAAA,OACA,GAAA,MACA,GAAA,OACA,GAAA,YACA,GAAA,YACA,GAAA,KACA,GAAA,OACA,GAAA,WACA,GAAA,KACA,GAAA,MACA,KAAA,KACA,KAAA,WACA,KAAA,KACA,KAAA,UACA,KAAA,UACA,KAAA,UACA,GAAA,MACA,GAAA,SACA,GAAA,KACA,GAAA,OACA,GAAA,OACA,GAAA,MACA,GAAA,MACA,GAAA,KACA,GAAA,MACA,GAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,MACA,KAAA,OACA,KAAA,MACA,GAAA,MACA,GAAA,KACA,GAAA,OACA,GAAA,OACA,GAAA,QACA,GAAA,OACA,GAAA,OACA,GAAA,SACA,GAAA,SACA,GAAA,OACA,KAAA,iBACA,KAAA,MACA,KAAA,OACA,KAAA,kBACA,KAAA,eACA,KAAA,OACA,GAAA,SACA,GAAA,MACA,GAAA,OACA,GAAA,YACA,GAAA,UACA,GAAA,WACA,GAAA,QACA,GAAA,OACA,GAAA,SACA,GAAA,OACA,KAAA,WACA,KAAA,MACA,KAAA,MACA,KAAA,WACA,KAAA,SACA,KAAA,OACA,GAAA,MACA,GAAA,UACA,GAAA,MACA,GAAA,SACA,GAAA,KACA,GAAA,OACA,GAAA,MACA,GAAA,YACA,GAAA,SACA,GAAA,QACA,KAAA,QACA,KAAA,YACA,KAAA,OACA,KAAA,YACA,KAAA,UACA,KAAA,SAGDC,EAAe,CACb,KAAA,MACA,KAAA,SACA,KAAA,MACA,KAAA,CAACjB,KAAM,OAAQD,IAAK,EAAGmB,OAAO,GAC9B,KAAA,CAAClB,KAAM,OAAQD,IAAK,EAAGmB,OAAO,GAC9B,KAAA,CAAClB,KAAM,OAAQD,IAAK,EAAGmB,OAAO,GAC9B,KAAA,CAAClB,KAAM,OAAQD,IAAK,EAAGmB,OAAO,GAC9B,KAAA,CAAClB,KAAM,OAAQD,IAAK,EAAGmB,OAAO,GAC9B,KAAA,CAAClB,KAAM,OAAQD,IAAK,EAAGmB,OAAO,GAC9B,KAAA,CAAClB,KAAM,OAAQD,IAAK,EAAGmB,OAAO,GAC9B,KAAA,SAGD,SAASC,EAAevF,GACvBwF,MAAAA,EAAyB,GAE3BxF,GAAAA,aAAiByF,YAEd,GAAIzF,aAAiB0F,OACtB1F,GAAAA,EAAMQ,MAAO,CACT2D,MAAAA,EAAMnE,EAAMQ,MAAMX,OAAS,EACjC2F,EAAOG,KAAK,MACZH,EAAOG,KAAKxB,EAAIyB,SAAS,IAAIC,SAAS,EAAG,MACzCL,EAAOG,KAAK3F,EAAMQ,YACTR,EAAM8F,KACfN,EAAOG,KAAK,MAITH,OAAAA,EAAOV,KAAK,IAGd,SAASiB,EAAevF,GAC7BA,EAAQA,EAAMwF,cAEVC,IAAAA,EAAQ,EAENC,MAAAA,EAAO/B,GAAO3D,EAAMF,MAAM2F,EAAOA,EAAQ9B,GAEzCgC,EAAO,KACLC,MAAAA,EAAIF,EAAK,GACTG,EAAOhB,EAAae,GAEtBC,GAAAA,aAAgBX,OAAQ,CAE1BO,GAAS,EACHK,MAAAA,EAAKlB,EAAWc,EAAK,IAIpB,OAHPD,GAAS,EAGF,CAACI,KAAMC,EAAIC,KADLd,MAAMe,MAAM,KAAM,IAAIf,MAAMY,EAAKlC,MACjBU,IAAI,IAAMsB,MAGnCC,GAAM,OAANA,EAAY,CAEdH,GAAS,EACH9B,MAAAA,EAAM+B,EAAK,GACjBD,GAAS,EACHQ,MAAAA,EAA8B,EAApBC,SAASvC,EAAK,IACxBwC,EAAOT,EAAKO,GAEX,OADPR,GAASQ,EACF,CAACjG,MAAOmG,GAEV,GAAU,OAANP,EAAY,CACrBH,GAAS,EACH9B,MAAAA,EAAM+B,EAAK,GACjBD,GAAS,EACHQ,MAAAA,EAA8B,EAApBC,SAASvC,EAAK,IACxBwC,EAAOT,EAAKO,GAClBR,GAASQ,EAEHG,MAAAA,EAAeD,EAAKE,MAAM,eAC5BD,GAAAA,aAAwBnB,MAAO,CAC3BqB,MAAAA,EAAa,IAAIlH,WAAWgH,EAAa/B,IAAIpF,GAAKiH,SAASjH,EAAG,MAC7D,MAAA,CAACsH,OAAQ,IAAIC,YAAY,SAAS3G,OAAOyG,IAE1C,KAAA,oBAGH,GAAU,OAANV,EAAY,CACrBH,GAAS,EAEHgB,MAAAA,EAAcP,SAASR,EAAK,GAAI,IAAIN,SAAS,GAAGC,SAAS,EAAG,KAClEI,GAAS,EACWgB,EAAY,GAA1BC,MAEAC,EAAc,CAACF,EAAY3G,MAAM,IAEnC8G,IAAAA,EAA+B,MAAnBH,EAAY,GACrBG,KAAAA,GAAW,CACV5G,MAAAA,EAAQkG,SAASR,EAAK,GAAI,IAAIN,SAAS,GAAGC,SAAS,EAAG,KAC5DI,GAAS,EAETkB,EAAYxB,KAAKnF,EAAMF,MAAM,IAC7B8G,EAAyB,MAAb5G,EAAM,GAIb,MAAA,CAACsF,IADI,IAAIuB,EAAJ,UAAcF,EAAYG,UAAUxC,KAAK,IAAK,GACzCc,YACZ,GAAU,OAANQ,EAAY,CACrBH,GAAS,EAEH9B,MAAAA,EAAM+B,EAAK,GACjBD,GAAS,EACHQ,MAAAA,EAA8B,EAApBC,SAASvC,EAAK,IAExBoD,GADOrB,EAAKO,GACJR,EAAQQ,GAEhBe,EAAU,GACTD,KAAAA,EAAQtB,GACbuB,EAAQ7B,KAAKQ,KAERqB,OAAAA,EAKL,KAAA,qBAGDrB,OAAAA,IAGM,IAAA,EAAA,CACblG,OAAAA,EACA8E,UAAAA,EACAhF,gBAAAA,EACAK,gBAAAA,EACAG,oBAAAA,EACA8D,kBAAAA,EACA7E,YAAAA,EACAuG,eAAAA,GARa,QAAA,QAAA;;ACnQA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,EAAA,QAAA,YAAA,EAAA,QAAA,WAAA,EAAA,QAAA,eAAA,EAAA,QAAA,gBAAA,EAAA,QAAA,cAAA,EAAA,QAAA,aAAA,EAtIf,IAAA,EAAA,EAAA,QAAA,UACA,EAAA,EAAA,QAAA,YACA,EAAA,EAAA,QAAA,aACA,EAAA,EAAA,QAAA,YACA,EAAA,EAAA,QAAA,WACA,EAAA,EAAA,QAAA,cAiIe,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,IAAA,EAAA,GAAA,GAAA,MAAA,EAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,OAAA,yBAAA,EAAA,GAAA,GAAA,EAAA,KAAA,EAAA,IAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,EAAA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GA9HR,SAAS0B,EAAYzH,EAAoBmE,EAAe,IACtDuD,OAAAA,EAAMC,QAAAA,QAAQ3H,EAAO,KAAMmE,GAG7B,SAASyD,EAAYC,GACnBC,OAAAA,EAAMC,QAAAA,iBAAiBF,GAGhC,MAAMG,EAMJC,YAAY7D,EAAyC8D,EAAyBC,GACvE/D,KAAAA,KAAOA,EACP8D,KAAAA,WAAaA,EACbC,KAAAA,QAAUA,EAEVC,KAAAA,QAAU,CACbC,QAAS,IACPC,EAAMvI,QAAAA,gBAAgB0H,EAAY,KAAKU,QAAS,IAAKG,EAAMrI,QAAAA,OAAOc,yBACpEwH,UAAW,IACTD,EAAMvI,QAAAA,gBAAgB0H,EAAY,KAAKU,QAAS,IAAKG,EAAMrI,QAAAA,OAAOe,2BACpEwH,KAAM,IACJF,EAAMvI,QAAAA,gBAAgB0H,EAAY,KAAKU,QAAS,IAAKG,EAAMrI,QAAAA,OAAOgB,uBACpE,KAAKmD,QAGTqE,eACS,MAAA,CACLJ,QAAS,IACPC,EAAMvI,QAAAA,gBAAgB,KAAKmI,WAAYI,EAAMrI,QAAAA,OAAO6B,oBACtDyG,UAAW,IACTD,EAAMvI,QAAAA,gBAAgB,KAAKmI,WAAYI,EAAMrI,QAAAA,OAAOoB,sBACtDmH,KAAM,IACJF,EAAMvI,QAAAA,gBAAgB,KAAKmI,WAAYI,EAAMrI,QAAAA,OAAOqB,kBACtD,KAAK8C,QAGTsE,eACS,MAAA,CACLL,QAAS,IACPC,EAAMvI,QAAAA,gBAAgB,KAAKoI,QAASG,EAAMrI,QAAAA,OAAOmB,oBACnDmH,UAAW,IACTD,EAAMvI,QAAAA,gBAAgB,KAAKoI,QAASG,EAAMrI,QAAAA,OAAOyB,sBACnD8G,KAAM,IACJF,EAAMvI,QAAAA,gBAAgB,KAAKoI,QAASG,EAAMrI,QAAAA,OAAO0B,kBACnD,KAAKyC,SAKJ,SAASuE,EAAWC,EAAoBC,GACvC5I,MAAAA,EAASqI,EAAM/H,QAAAA,oBAAoBqI,GACnCE,EAAkBR,EAAMlI,QAAAA,gBAAgBwI,EAAW3I,EAAOO,OAC1DuI,EAAOD,EAAgBxI,MAAM,EAAG,GAChC0I,EAAgBF,EAAgBxI,MAAM,GACtC4D,EAAM+E,EAAOC,QAAAA,WAAWL,EAAUE,EAAM,MAAO,GAAI,UACnDvD,EAAS2D,EAAUC,UAAAA,KAAKJ,EAAe,IAAIpJ,WAAW,IAAKsE,GAC3DmF,EAAc,CAClB9H,uBAAyB+H,IACP,IAAI9E,EAAS+E,QAAAA,MAAM,WAA7BlB,MACAmB,EAAWC,EAAKC,QAAAA,KAAKC,QAAQC,SAASN,GACrC,OAAA,IAAItB,EAAI,UAAWwB,EAASK,UAAWL,EAASM,YAEzDtI,+BAAiC0C,IACzBsF,MAAAA,EAAY,IAAIhF,EAASuF,QAAAA,GAAG,aAAcC,eAAe9F,GACzDiE,EAAU,IAAIvI,WAAW,CAAC,GAAGqK,OAAOT,EAASU,YAAYC,OAAOC,YAC/D,OAAA,IAAIpC,EAAI,YAAa9D,EAAKiE,IAEnC1G,0BAA4ByC,IACpBsF,MAAAA,EAAY,IAAIhF,EAASuF,QAAAA,GAAG,QAASC,eAAe9F,GACpDiE,EAAU,IAAIvI,WAAW,CAAC,GAAGqK,OAAOT,EAASU,YAAYC,OAAOC,YAC/D,OAAA,IAAIpC,EAAI,OAAQ9D,EAAKiE,KAI5BlI,GAAAA,EAAOmE,QAAQiF,EACVA,OAAAA,EAAYpJ,EAAOmE,MAAMoB,GAE1B,KAAA,0CAIH,SAAS6E,EAAef,GACvBgB,MAAAA,EAA6B,iBAAThB,EAAoBhB,EAAMlI,QAAAA,gBAAgBkJ,GAAQA,EACtEE,EAAWC,EAAKC,QAAAA,KAAKC,QAAQC,SAASU,GACrC,OAAA,IAAItC,EAAI,UAAWwB,EAASK,UAAWL,EAASM,WAGlD,SAASS,EAAgBC,EAAgC3B,GACxD4B,MAAAA,EAAWD,aAAiB/E,MAAQ+E,EAAM1F,KAAK,KAAO0F,EAErDH,OAAAA,EADYvC,EAAM4C,QAAAA,eAAeD,EAAU5B,GAAUvI,MAAM,EAAG,KAIhE,SAASqK,EAAcC,EAA8B1C,GACpD2C,MACAnK,EAAiB+G,EADEa,EAAM9I,QAAAA,YAAY8I,EAAMvD,QAAAA,UAAUG,YAAa0F,IAElE3K,EAASqI,EAAM/H,QAAAA,oBAAoB2H,GACnC4C,EAAc,CAClBhJ,mBAAoBwG,EAAMrI,QAAAA,OAAO8B,kBACjCV,qBAAsBiH,EAAMrI,QAAAA,OAAO+B,oBACnCV,gBAAiBgH,EAAMrI,QAAAA,OAAOgC,gBAG1B8I,EAAmBzC,EAAMlI,QAAAA,gBAAgB8H,EAAYjI,EAAOO,OAE9DP,GAAAA,EAAOmE,QAAQ0G,EAAa,CACxB5G,MAAAA,EAAM,CACVpC,mBAAoB,IAAO,IAAI0C,EAAS+E,QAAAA,MAAM,WAAYyB,cAAcD,GACxE1J,qBAAsB,IAAO,IAAImD,EAASuF,QAAAA,GAAG,aAAcC,eAAee,GAC1EzJ,gBAAiB,IAAO,IAAIkD,EAASuF,QAAAA,GAAG,QAASC,eAAee,IAChE9K,EAAOmE,QAEH6G,EAA4B,uBAAhBhL,EAAOmE,KACvB,IAAIxE,WAAWsE,EAAIwF,KAAKhJ,GAAgBwK,WACxC,CAACpH,GAAO,IAAIlE,WAAWkE,EAAIqH,EAAEf,UAAUH,OAAOnG,EAAIsH,EAAEhB,YAApD,CAAiElG,EAAIwF,KAAKhJ,IAErE4H,OAAAA,EAAMvI,QAAAA,gBAAgBkL,EAAWH,EAAY7K,EAAOmE,OAEpD,4BAAsB8D,IAIlB,IAAA,EAAA,CACbN,YAAAA,EACAyC,eAAAA,EACAE,gBAAAA,EACA5B,WAAAA,EACAgC,cAAAA,GALa,QAAA,QAAA;;ACnIA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAHf,IAAA,EAAA,EAAA,QAAA,YACA,EAAA,EAAA,QAAA,aAEe,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,IAAA,EAAA,CACbrC,MAAAA,EADa,QAEbW,OAAAA,EAAAA,SAFa,QAAA,QAAA;;ACDR,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,EAFP,IAAA,EAAA,EAAA,QAAA,WAEO,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,MAAMoC,EAAS,CAACC,EAAQC,KACrBC,EAAAA,QAAAA,GAAGF,EAAGC,GACdE,QAAQC,IAAI,cAAoB,SAAUH,IAFrC,QAAA,OAAA;;ACoGH,aAtGJ,IAAA,EAAA,EAAA,QAAA,mBACA,EAAA,QAAA,UAqGI,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAnGJ,MAAMI,EAAMC,EAAZ,QAEMC,EAAW,UACf,CACQV,MAAAA,EAAIQ,EAAIrD,MAAMvC,eAAe,4JAC7B+F,EAAS,wTACRC,EAAAA,EAAAA,QAAAA,KAAKC,UAAUb,KAAOW,EAAQ,sBAGvC,CACQG,MAAAA,EAAK,IAAIrM,WAAW,IACpBsM,EAAK,IAAItM,WAAW,CAAC,IACrBuM,EAAK,IAAIvM,WAAW,CAAC,EAAG,MAC9B,CACQuL,MAAAA,EAAIQ,EAAIrD,MAAM9I,YAAYyM,EAAIA,IAC7Bd,EAAAA,EAAAA,QAAa,IAAbA,EAAEtL,OAAc,oCAEzB,CACQsL,MAAAA,EAAIQ,EAAIrD,MAAM9I,YAAYyM,EAAIC,IAC7Bf,EAAAA,EAAAA,QAAa,IAAbA,EAAEtL,QAAyB,IAATsL,EAAE,GAAU,wCAEvC,CACQA,MAAAA,EAAIQ,EAAIrD,MAAM9I,YAAY0M,EAAIC,IAC7BhB,EAAAA,EAAAA,QAAa,IAAbA,EAAEtL,QAAyB,IAATsL,EAAE,IAAqB,IAATA,EAAE,IAAqB,MAATA,EAAE,GAChD,6CAIX,CACQiB,MAAAA,EAAS,uCACTnM,EAAS0L,EAAIrD,MAAMrI,OAAOc,wBAC1BP,EAAQmL,EAAIrD,MAAMlI,gBAAgBgM,EAAQnM,GAC1CoM,EAAaV,EAAIrD,MAAMlI,gBAAgBgM,IACtC5L,EAAAA,EAAAA,QAAiB,KAAjBA,EAAMX,QAAiBW,EAAMoF,aAAeyG,EAAWzG,WAAY,uBACpE0G,MAAAA,EAAMX,EAAIrD,MAAMvI,gBAAgBS,EAAOP,IACtCqM,EAAAA,EAAAA,QAAAA,IAAQF,EAAQ,uBAGzB,CACQG,MAAAA,EAAUZ,EAAI1C,OAAOrB,YAAY,MAChC2E,EAAAA,EAAAA,QAA8B,KAA9BA,EAAQC,MAAM,KAAK3M,OAAe,uBAEnC4M,MAAAA,EAAUd,EAAI1C,OAAOrB,YAAY,MAChC6E,EAAAA,EAAAA,QAA8B,KAA9BA,EAAQD,MAAM,KAAK3M,OAAe,uBAEnC6M,MAAAA,EAAUf,EAAI1C,OAAOrB,YAAY,MAChC8E,EAAAA,EAAAA,QAA8B,KAA9BA,EAAQF,MAAM,KAAK3M,OAAe,uBAEnCqE,MACAgE,EADMyD,EAAI1C,OAAOsB,gBAAgBmC,EAAS,WACzBjE,gBAChBP,EAAAA,EAAAA,QAA0B,SAA1BA,EAAW5H,MAAM,EAAE,IAAuC,KAAtB4H,EAAWrI,OAAe,uBAGvE,CACQ8E,MAAAA,EAAUgH,EAAIrD,MAAMjE,kBAAkB,yCACrCM,EAAAA,EAAAA,QAAY,kDAAZA,EAA6D,yBAGtE,CACQX,MAAAA,EAAQ2H,EAAI1C,OAAO0B,cAAc,IAAI/K,WAAW,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,IAAK,sGAChEqE,EAAS0H,EAAI1C,OAAO0B,cAAc,IAAI/K,WAAW,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,IAAK,0DACjEmE,EAAQ4H,EAAI1C,OAAO0B,cAAc,IAAI/K,WAAW,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,IAAK,0DAEhE+M,EAAehB,EAAIrD,MAAM/H,oBAAoByD,GAC7C4I,EAAgBjB,EAAIrD,MAAM/H,oBAAoB0D,GAC9C4I,EAAelB,EAAIrD,MAAM/H,oBAAoBwD,IAE5CC,EAAAA,EAAAA,QAAiB,KAAjBA,EAAMnE,QAAuC,sBAAtB8M,EAAavI,KAA8B,4BAClEH,EAAAA,EAAAA,QAAkB,KAAlBA,EAAOpE,QAAwC,wBAAvB+M,EAAcxI,KAAgC,6BACtEL,EAAAA,EAAAA,QAAiB,KAAjBA,EAAMlE,QAAuC,mBAAtBgN,EAAazI,KAA2B,2BAGxE,CACQT,MAAAA,EAAQgI,EAAI1C,OAAON,WAAW,2FAA4F,KAC1H/E,EAAQ+H,EAAI1C,OAAON,WAAW,2FAA4F,KAC1H9E,EAAQ8H,EAAI1C,OAAON,WAAW,2FAA4F,MAG9HhF,EAAAA,EAAAA,QAAkB,yCAAlBA,EAAMyE,SACsB,2DAAzBzE,EAAM+E,eACT,yBAGA9E,EAAAA,EAAAA,QAAkB,yCAAlBA,EAAMwE,SACsB,4DAAzBxE,EAAM8E,eACT,yBAGA7E,EAAAA,EAAAA,QAAkB,yCAAlBA,EAAMuE,SACsB,4DAAzBvE,EAAM6E,eACT,0BAKAoE,EAAO,gBACLjB,KAGRiB","file":"test.map","sourceRoot":"../test","sourcesContent":["// @flow\n\nimport { BigNumber } from 'bignumber.js'\nimport bs58check from 'bs58check'\nimport elliptic from 'elliptic'\nimport type { Micheline } from './types'\n\n\nexport function bytesConcat(x : Uint8Array, y : Uint8Array) {\n  const tmp = new Uint8Array(x.length + y.length)\n  tmp.set(x, 0)\n  tmp.set(y, x.length)\n  return tmp\n}\n\nexport function bs58checkEncode(input : Uint8Array, prefix : Uint8Array) {\n  return bs58check.encode(bytesConcat(prefix, input))\n}\n\nexport function bs58checkDecode(input : string, prefix? : Uint8Array) {\n  return bs58check.decode(input).slice(prefix ? prefix.length : bs58checkPrefixPick(input).bytes.length)\n}\n\nexport const prefix = {\n  block_hash: new Uint8Array([1, 52]), // B(51)\n  operation_hash: new Uint8Array([5, 116]), // o(51)\n  operation_list_hash: new Uint8Array([133, 233]), // Lo(52)\n  operation_list_list_hash: new Uint8Array([29, 159, 109]), // LLo(53)\n  protocol_hash: new Uint8Array([2, 170]), // P(51)\n  context_hash: new Uint8Array([79, 199]), // Co(52)\n\n  ed25519_public_key_hash: new Uint8Array([6, 161, 159]), // tz1(36)\n  secp256k1_public_key_hash: new Uint8Array([6, 161, 161]), // tz2(36)\n  p256_public_key_hash: new Uint8Array([6, 161, 164]), // tz3(36)\n\n  cryptobox_public_key_hash: new Uint8Array([153, 103]), // id(30)\n\n  ed25519_seed: new Uint8Array([13, 15, 58, 7]), // edsk(54)\n  ed25519_public_key: new Uint8Array([13, 15, 37, 217]), // edpk(54)\n  secp256k1_secret_key: new Uint8Array([17, 162, 224, 201]), // spsk(54)\n  p256_secret_key: new Uint8Array([16, 81, 238, 189]), // p2sk(54)\n\n  ed25519_encrypted_seed: new Uint8Array([7, 90, 60, 179, 41]), // edesk(88)\n  secp256k1_encrypted_secret_key: new Uint8Array([9, 237, 241, 174, 150]), // spesk(88)\n  p256_encrypted_secret_key: new Uint8Array([9, 48, 57, 115, 171]), // p2esk(88)\n\n  secp256k1_public_key: new Uint8Array([3, 254, 226, 86]), // sppk(55)\n  p256_public_key: new Uint8Array([3, 178, 139, 127]), // p2pk(55)\n  secp256k1_scalar: new Uint8Array([38, 248, 136]), // SSp(53)\n  secp256k1_element: new Uint8Array([5, 92, 0]), // GSp(54)\n\n  ed25519_secret_key: new Uint8Array([43, 246, 78, 7]), // edsk(98)\n  ed25519_signature: new Uint8Array([9, 245, 205, 134, 18]), // edsig(99)\n  secp256k1_signature: new Uint8Array([13, 115, 101, 19, 63]), // spsig1(99)\n  p256_signature: new Uint8Array([54, 240, 44, 52]), // p2sig(98)\n  generic_signature: new Uint8Array([4, 130, 43]), // sig(96)\n\n  chain_id: new Uint8Array([7, 82, 0]), // Net(15)\n\n  contract_hash: new Uint8Array([2, 90, 121]) // KT1(36)\n}\n\nexport function bs58checkPrefixPick(input : string) : {bytes: Uint8Array, name: string} {\n  const prefix_mapping = {\n    [15]: {\n      Net: 'chain_id'\n    },\n    [30]: {\n      id: 'cryptobox_public_key_hash'\n    },\n    [36]: {\n      tz1: 'ed25519_public_key_hash',\n      tz2: 'secp256k1_public_key_hash',\n      tz3: 'p256_public_key_hash',\n      KT1: 'contract_hash'\n    },\n    [51]: {\n      B: 'block_hash',\n      o: 'operation_hash',\n      P: 'protocol_hash'\n    },\n    [52]: {\n      Lo: 'operation_list_hash',\n      Co: 'context_hash'\n    },\n    [53]: {\n      LLo: 'operation_list_list_hash',\n      SSp: 'secp256k1_scalar'\n    },\n    [54]: {\n      edsk: 'ed25519_seed',\n      edpk: 'ed25519_public_key',\n      spsk: 'secp256k1_secret_key',\n      p2sk: 'p256_secret_key',\n      GSp: 'secp256k1_element'\n    },\n    [55]: {\n      sppk: 'secp256k1_public_key',\n      p2pk: 'p256_public_key'\n    },\n    [88]: {\n      edesk: 'ed25519_encrypted_seed',\n      spesk: 'secp256k1_encrypted_secret_key',\n      p2esk: 'p256_encrypted_secret_key'\n    },\n    [96]: {\n      sig: 'generic_signature'\n    },\n    [98]: {\n      edsk: 'ed25519_secret_key',\n      p2sig: 'p256_signature'\n    },\n    [99]: {\n      edsig: 'ed25519_signature',\n      spsig1: 'secp256k1_signature'\n    }\n  }\n\n  const matched_mapping = prefix_mapping[input.length]\n  if (matched_mapping) {\n    for (const key in matched_mapping) {\n      const len = key.length\n      if (input.slice(0, len) === key)\n        return {bytes: prefix[matched_mapping[key]], name:matched_mapping[key]} \n    }\n  }\n\n  throw `No prefix found for: ${input}`\n}\n\nexport function getContractHexKey(contract : string) {\n  if (contract.length !== 36 || contract.slice(0, 3) !== 'KT1')\n    throw `invalid contract: ${contract}`\n\n  const bytes = bs58checkDecode(contract, prefix.contract_hash)\n  const hex = elliptic.utils.toHex(bytes)\n  const hex_key = [[0,2], [2,4], [4,6], [6,8], [8,10], [10,undefined]].map(x => hex.slice(x[0], x[1])).join('/')\n\n  return hex_key\n}\n\nexport const watermark = {\n  block_header(chain_id : Uint8Array) {\n    return bytesConcat(new Uint8Array([1]), chain_id)\n  },\n  endorsement(chain_id : Uint8Array) {\n    return bytesConcat(new Uint8Array([2]), chain_id)\n  },\n  operation() {\n    return new Uint8Array([3])\n  },\n  custom(x : Uint8Array) {\n    return x\n  }\n}\n\nconst op_mapping = {\n  '00':'parameter',\n  '01':'storage',\n  '02':'code',\n  '03':'False',\n  '04':'Elt',\n  '05':'Left',\n  '06':'None',\n  '07':'Pair',\n  '08':'Right',\n  '09':'Some',\n  '0A':'True',\n  '0B':'Unit',\n  '0C':'PACK',\n  '0D':'UNPACK',\n  '0E':'BLAKE2B',\n  '0F':'SHA256',\n  '10':'SHA512',\n  '11':'ABS',\n  '12':'ADD',\n  '13':'AMOUNT',\n  '14':'AND',\n  '15':'BALANCE',\n  '16':'CAR',\n  '17':'CDR',\n  '18':'CHECK_SIGNATURE',\n  '19':'COMPARE',\n  '1A':'CONCAT',\n  '1B':'CONS',\n  '1C':'CREATE_ACCOUNT',\n  '1D':'CREATE_CONTRACT',\n  '1E':'IMPLICIT_ACCOUNT',\n  '1F':'DIP',\n  '20':'DROP',\n  '21':'DUP',\n  '22':'EDIV',\n  '23':'EMPTY_MAP',\n  '24':'EMPTY_SET',\n  '25':'EQ',\n  '26':'EXEC',\n  '27':'FAILWITH',\n  '28':'GE',\n  '29':'GET',\n  '2A':'GT',\n  '2B':'HASH_KEY',\n  '2C':'IF',\n  '2D':'IF_CONS',\n  '2E':'IF_LEFT',\n  '2F':'IF_NONE',\n  '30':'INT',\n  '31':'LAMBDA',\n  '32':'LE',\n  '33':'LEFT',\n  '34':'LOOP',\n  '35':'LSL',\n  '36':'LSR',\n  '37':'LT',\n  '38':'MAP',\n  '39':'MEM',\n  '3A':'MUL',\n  '3B':'NEG',\n  '3C':'NEQ',\n  '3D':'NIL',\n  '3E':'NONE',\n  '3F':'NOT',\n  '40':'NOW',\n  '41':'OR',\n  '42':'PAIR',\n  '43':'PUSH',\n  '44':'RIGHT',\n  '45':'SIZE',\n  '46':'SOME',\n  '47':'SOURCE',\n  '48':'SENDER',\n  '49':'SELF',\n  '4A':'STEPS_TO_QUOTA',\n  '4B':'SUB',\n  '4C':'SWAP',\n  '4D':'TRANSFER_TOKENS',\n  '4E':'SET_DELEGATE',\n  '4F':'UNIT',\n  '50':'UPDATE',\n  '51':'XOR',\n  '52':'ITER',\n  '53':'LOOP_LEFT',\n  '54':'ADDRESS',\n  '55':'CONTRACT',\n  '56':'ISNAT',\n  '57':'CAST',\n  '58':'RENAME',\n  '59':'bool',\n  '5A':'contract',\n  '5B':'int',\n  '5C':'key',\n  '5D':'key_hash',\n  '5E':'lambda',\n  '5F':'list',\n  '60':'map',\n  '61':'big_map',\n  '62':'nat',\n  '63':'option',\n  '64':'or',\n  '65':'pair',\n  '66':'set',\n  '67':'signature',\n  '68':'string',\n  '69':'bytes',\n  '6A':'mutez',\n  '6B':'timestamp',\n  '6C':'unit',\n  '6D':'operation',\n  '6E':'address',\n  '6F':'SLICE',\n}\n\nconst prim_mapping = {\n  '00': 'int',    \n  '01': 'string',             \n  '02': 'seq',             \n  '03': {name: 'prim', len: 0, annot: false},          \n  '04': {name: 'prim', len: 0, annot: true},\n  '05': {name: 'prim', len: 1, annot: false},           \n  '06': {name: 'prim', len: 1, annot: true},   \n  '07': {name: 'prim', len: 2, annot: false},          \n  '08': {name: 'prim', len: 2, annot: true},  \n  '09': {name: 'prim', len: 3, annot: true},\n  '0A': 'bytes'                  \n}\n\nexport function encodeRawBytes(input : Micheline) : string {\n  const result : Array<string> = []\n\n  if (input instanceof Array) {\n\n  } else if (input instanceof Object) {\n    if (input.bytes) {\n      const len = input.bytes.length / 2\n      result.push('0A')\n      result.push(len.toString(16).padStart(8, '0'))\n      result.push(input.bytes)\n    } else if (input.int) {\n      result.push('00')\n    }\n  }\n\n  return result.join('')\n}\n\nexport function decodeRawBytes(bytes : string) : Micheline {\n  bytes = bytes.toUpperCase()\n  \n  let index = 0\n\n  const read = len => bytes.slice(index, index + len)\n\n  const walk = () => {\n    const b = read(2)\n    const prim = prim_mapping[b]\n    \n    if (prim instanceof Object) {\n\n      index += 2\n      const op = op_mapping[read(2)]\n      index += 2\n\n      const args = Array.apply(null, new Array(prim.len))\n      return {prim: op, args: args.map(() => walk())}\n\n    } else {\n      if (b === '0A') {\n\n        index += 2\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        index += int_len\n        return {bytes: data}\n\n      } else if (b === '01') {\n        index += 2\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        index += int_len\n\n        const match_result = data.match(/[\\dA-F]{2}/g)\n        if (match_result instanceof Array) {\n          const string_raw = new Uint8Array(match_result.map(x => parseInt(x, 16)))\n          return {string: new TextDecoder('utf-8').decode(string_raw)}\n        } else {\n          throw \"Input bytes error\"\n        }\n\n      } else if (b === '00') {\n        index += 2\n\n        const first_bytes = parseInt(read(2), 16).toString(2).padStart(8, '0')\n        index += 2\n        const is_positive = first_bytes[1] === '0'\n\n        const valid_bytes = [first_bytes.slice(2)]\n\n        let checknext = first_bytes[0] === '1'\n        while (checknext) {\n          const bytes = parseInt(read(2), 16).toString(2).padStart(8, '0')\n          index += 2\n\n          valid_bytes.push(bytes.slice(1))\n          checknext = bytes[0] === '1'\n        }\n\n        const num = new BigNumber(valid_bytes.reverse().join(''), 2)\n        return {int: num.toString()}\n      } else if (b === '02') {\n        index += 2\n\n        const len = read(8)\n        index += 8\n        const int_len = parseInt(len, 16) * 2\n        const data = read(int_len)\n        const limit = index + int_len\n\n        const seq_lst = []\n        while (limit > index) {\n          seq_lst.push(walk())\n        }\n        return seq_lst\n      }\n\n    }\n\n    throw 'Invalid raw bytes'\n  }\n\n  return walk()\n}\n\nexport default {\n  prefix,\n  watermark,\n  bs58checkEncode,\n  bs58checkDecode,\n  bs58checkPrefixPick,\n  getContractHexKey,\n  bytesConcat,\n  decodeRawBytes\n}","// @flow\n\nimport bip39 from 'bip39'\nimport codec from './codec'\nimport elliptic from 'elliptic'\nimport blake from 'blakejs'\nimport crypto from 'crypto'\nimport { secretbox } from 'tweetnacl'\nimport nacl from 'tweetnacl'\n\nexport function blake2bHash(input : Uint8Array, len : number = 32) {\n  return blake.blake2b(input, null, len)\n}\n\nexport function getMnemonic(strength? : number) {\n  return bip39.generateMnemonic(strength)\n}\n\nclass Key {\n  name : string\n  secret_key : Uint8Array\n  pub_key : Uint8Array\n  address : string\n\n  constructor(name : 'ed25519' | 'secp256k1' | 'p256', secret_key : Uint8Array, pub_key : Uint8Array) {\n    this.name = name\n    this.secret_key = secret_key\n    this.pub_key = pub_key\n\n    this.address = {\n      ed25519: () => \n        codec.bs58checkEncode(blake2bHash(this.pub_key, 20), codec.prefix.ed25519_public_key_hash),\n      secp256k1: () => \n        codec.bs58checkEncode(blake2bHash(this.pub_key, 20), codec.prefix.secp256k1_public_key_hash),\n      p256: () => \n        codec.bs58checkEncode(blake2bHash(this.pub_key, 20), codec.prefix.p256_public_key_hash) \n    }[this.name]()\n  }\n\n  getSecretKey() {\n    return {\n      ed25519: () => \n        codec.bs58checkEncode(this.secret_key, codec.prefix.ed25519_secret_key),\n      secp256k1: () => \n        codec.bs58checkEncode(this.secret_key, codec.prefix.secp256k1_secret_key),\n      p256: () => \n        codec.bs58checkEncode(this.secret_key, codec.prefix.p256_secret_key)\n    }[this.name]()\n  }\n\n  getPublicKey() {\n    return {\n      ed25519: () => \n        codec.bs58checkEncode(this.pub_key, codec.prefix.ed25519_public_key),\n      secp256k1: () => \n        codec.bs58checkEncode(this.pub_key, codec.prefix.secp256k1_public_key),\n      p256: () => \n        codec.bs58checkEncode(this.pub_key, codec.prefix.p256_public_key)\n    }[this.name]()\n  }\n}\n\n\nexport function decryptKey(encrypted : string, password : string) : Key {\n  const prefix = codec.bs58checkPrefixPick(encrypted)\n  const encrypted_bytes = codec.bs58checkDecode(encrypted, prefix.bytes)\n  const salt = encrypted_bytes.slice(0, 8)\n  const encrypted_msg = encrypted_bytes.slice(8)\n  const key = crypto.pbkdf2Sync(password, salt, 32768, 32, 'sha512')\n  const result = secretbox.open(encrypted_msg, new Uint8Array(24), key)\n  const key_mapping = {\n    ed25519_encrypted_seed: (seed) => {\n      const ed25519 = new elliptic.eddsa('ed25519')\n      const key_pair = nacl.sign.keyPair.fromSeed(seed)\n      return new Key('ed25519', key_pair.secretKey, key_pair.publicKey)\n    },\n    secp256k1_encrypted_secret_key: (key) => {\n      const key_pair = (new elliptic.ec('secp256k1')).keyFromPrivate(key)\n      const pub_key = new Uint8Array([2].concat(key_pair.getPublic().getX().toArray()))\n      return new Key('secp256k1', key, pub_key)\n    },\n    p256_encrypted_secret_key: (key) =>  {\n      const key_pair = (new elliptic.ec('p256')).keyFromPrivate(key)\n      const pub_key = new Uint8Array([3].concat(key_pair.getPublic().getX().toArray()))\n      return new Key('p256', key, pub_key)\n    }\n  }\n\n  if (prefix.name in key_mapping) {\n    return key_mapping[prefix.name](result)\n  } else {\n    throw 'No valid prefix for encrypted key found'\n  }\n}\n\nexport function getKeyFromSeed(seed : string | Uint8Array) {\n  const seed_bytes = typeof seed === 'string' ? codec.bs58checkDecode(seed) : seed\n  const key_pair = nacl.sign.keyPair.fromSeed(seed_bytes)\n  return new Key('ed25519', key_pair.secretKey, key_pair.publicKey)\n}\n\nexport function getKeyFromWords(words : string | Array<string>, password? : string) {\n  const mnemonic = words instanceof Array ? words.join(' ') : words\n  const seed_bytes = bip39.mnemonicToSeed(mnemonic, password).slice(0, 32)\n  return getKeyFromSeed(seed_bytes)\n}\n\nexport function signOperation(operation_bytes : Uint8Array, secret_key : string) {\n  const marked_operation = codec.bytesConcat(codec.watermark.operation(), operation_bytes)\n  const operation_hash = blake2bHash(marked_operation)\n  const prefix = codec.bs58checkPrefixPick(secret_key)\n  const sig_mapping = {\n    ed25519_secret_key: codec.prefix.ed25519_signature,\n    secp256k1_secret_key: codec.prefix.secp256k1_signature,\n    p256_secret_key: codec.prefix.p256_signature\n  }\n\n  const secret_key_bytes = codec.bs58checkDecode(secret_key, prefix.bytes)\n\n  if (prefix.name in sig_mapping) {\n    const key = {\n      ed25519_secret_key: () => (new elliptic.eddsa('ed25519')).keyFromSecret(secret_key_bytes),\n      secp256k1_secret_key: () => (new elliptic.ec('secp256k1')).keyFromPrivate(secret_key_bytes),\n      p256_secret_key: () => (new elliptic.ec('p256')).keyFromPrivate(secret_key_bytes)\n    }[prefix.name]()\n\n    const sig_bytes = prefix.name === 'ed25519_secret_key' ? \n      new Uint8Array(key.sign(operation_hash).toBytes()) :\n      (sig => new Uint8Array(sig.r.toArray().concat(sig.s.toArray())))(key.sign(operation_hash)) \n\n    return codec.bs58checkEncode(sig_bytes, sig_mapping[prefix.name])\n  } else {\n    throw `invalid prefix for: ${secret_key}`\n  }\n}\n\nexport default {\n  getMnemonic,\n  getKeyFromSeed,\n  getKeyFromWords,\n  decryptKey,\n  signOperation\n}","// @flow\n\nimport codec from './codec'\nimport crypto from './crypto'\n\nexport default {\n  codec,\n  crypto\n}","// @flow\n\nimport _assert from 'assert'\n\nexport const assert = (v: any, m : string) => {\n  _assert.ok(v, m)\n  console.log('\\x1b[32m%s\\x1b[0m','PASS @', m)\n}\n","// @flow\n\nimport TezBridgeCrypto from './../src/index'\nimport { assert } from './util'\n\nconst TBC = TezBridgeCrypto\n\nconst fn_tests = async () => {\n  {\n    const r = TBC.codec.decodeRawBytes('07070a0000001601b2a4f12006b191111b11faa0a126bcddded861de0007070a000000160000f9a61eefd5d12786e70433b1edc846ac9eb5fcd60707030a0707009503070700a3db97010000')\n    const answer = '{\"prim\":\"Pair\",\"args\":[{\"bytes\":\"01B2A4F12006B191111B11FAA0A126BCDDDED861DE00\"},{\"prim\":\"Pair\",\"args\":[{\"bytes\":\"0000F9A61EEFD5D12786E70433B1EDC846AC9EB5FCD6\"},{\"prim\":\"Pair\",\"args\":[{\"prim\":\"True\",\"args\":[]},{\"prim\":\"Pair\",\"args\":[{\"int\":\"213\"},{\"prim\":\"Pair\",\"args\":[{\"int\":\"1242851\"},{\"int\":\"0\"}]}]}]}]}]}'\n    assert(JSON.stringify(r) === answer, 'FN: decodeRawBytes')\n  }\n\n  {\n    const a1 = new Uint8Array([])\n    const a2 = new Uint8Array([1])\n    const a3 = new Uint8Array([2, 255])\n    {\n      const r = TBC.codec.bytesConcat(a1, a1)\n      assert(r.length === 0, 'FN: bytesConcat empty with empty')\n    }\n    {\n      const r = TBC.codec.bytesConcat(a1, a2)\n      assert(r.length === 1 && r[0] === 1, 'FN: bytesConcat empty with non-empty')\n    }\n    {\n      const r = TBC.codec.bytesConcat(a2, a3)\n      assert(r.length === 3 && r[0] === 1 && r[1] === 2 && r[2] === 255, \n             'FN: bytesConcat non-empty with non-empty')\n    }\n  }\n\n  {\n    const source = 'tz1TUswtLE1cTBgoBC2JAtQ5Jsz2crp1tZvJ'\n    const prefix = TBC.codec.prefix.ed25519_public_key_hash\n    const bytes = TBC.codec.bs58checkDecode(source, prefix)\n    const bytes_auto = TBC.codec.bs58checkDecode(source)\n    assert(bytes.length === 20 && bytes.toString() === bytes_auto.toString(), 'FN: bs58checkDecode')\n    const str = TBC.codec.bs58checkEncode(bytes, prefix)\n    assert(str === source, 'FN: bs58checkEncode')\n  }\n\n  {\n    const words12 = TBC.crypto.getMnemonic(128)\n    assert(words12.split(' ').length === 12, 'FN: getMnemonic 128')\n\n    const words18 = TBC.crypto.getMnemonic(192)\n    assert(words18.split(' ').length === 18, 'FN: getMnemonic 192')\n\n    const words24 = TBC.crypto.getMnemonic(256)\n    assert(words24.split(' ').length === 24, 'FN: getMnemonic 256')\n\n    const key = TBC.crypto.getKeyFromWords(words24, 'abcdefg')\n    const secret_key = key.getSecretKey()\n    assert(secret_key.slice(0,4) === 'edsk' && secret_key.length === 98, 'FN: getKeyFromWords')\n  }\n\n  {\n    const hex_key = TBC.codec.getContractHexKey('KT1UynVe2zgSht3QHFUDpWkKvonFrcE1PZ8q')\n    assert(hex_key === 'df/bc/db/b1/14/77863511f6ada9978be77b690be14a', 'FN: getContractHexKey')\n  }\n\n  {\n    const edsig = TBC.crypto.signOperation(new Uint8Array([1,2,3,4,5,6]), 'edskS68LAmi2nQHCEzvMs9CAJaCpWWtkFTavc2DBnxLaNvFerXBgjggKNu9QFPTyT5BuE1ttNbkHj7c3Q4AuPtjaFzfyj4t9un')\n    const spsig1 = TBC.crypto.signOperation(new Uint8Array([1,2,3,4,5,6]), 'spsk2nG1XBRvSJmh6BiwcBxox5DpMn4NcRzJakgACsrydqXRhXfBej')\n    const p2sig = TBC.crypto.signOperation(new Uint8Array([1,2,3,4,5,6]), 'p2sk2ucp48wneFz9rwDvd4vsoqxNWHe5QTKcfnJ1JAyVJ3y77PgPSr')\n\n    const edsig_prefix = TBC.codec.bs58checkPrefixPick(edsig)\n    const spsig1_prefix = TBC.codec.bs58checkPrefixPick(spsig1)\n    const p2sig_prefix = TBC.codec.bs58checkPrefixPick(p2sig)\n\n    assert(edsig.length === 99 && edsig_prefix.name === 'ed25519_signature', 'FN: signOperation edsig')\n    assert(spsig1.length === 99 && spsig1_prefix.name === 'secp256k1_signature', 'FN: signOperation spsig1')\n    assert(p2sig.length === 98 && p2sig_prefix.name === 'p256_signature', 'FN: signOperation p2sig')\n  }\n\n  {\n    const edesk = TBC.crypto.decryptKey('edesk1TgH1sGSQ2rwM1Sk475ikTLqeYrSH2a6tvUuZdzkox8C91n55pVGo7QpxbFhT1KAe3zpPFWPvrusrBY9fnc', 'a')\n    const spesk = TBC.crypto.decryptKey('spesk29FVwwKJ4FXpJtGKraxS4QcDeaoBL1JPsnqnofUSAf9yFioRbfRq5eJEoXpcUBPKnFjj8WEfj7cQjZkRxAs', 'a')\n    const p2esk = TBC.crypto.decryptKey('p2esk1qLhMDUemxyMkfjAjmKw5QQSp7FhGadvBgthrehjWwJSofUtcd56HpEv8GqutoA3hC8wMAqeU2sX5p4XHjX', 'a')\n\n    assert(\n      edesk.address === 'tz1hgWvYdzLECdrq5zndGHwCGnUCJq1KFe3r'\n      && edesk.getPublicKey() === 'edpkunm1aRnRtHwVsBGSFgKmw5EhBn4gR6NC5JqVoAi57viSgAN3t5',\n      'FN: decryptKey edesk')\n\n    assert(\n      spesk.address === 'tz2L2HuhaaSnf6ShEDdhTEAr5jGPWPNwpvcB'\n      && spesk.getPublicKey() === 'sppk7aLxNrEXqt52YTEXmVwKQSu2phVrjnSQmF7V31xSAFXEq9PSETE', \n      'FN: decryptKey spesk')\n\n    assert(\n      p2esk.address === 'tz3Vrs3r11Tu9fZvu4mHFcuNt9FK9QuCw83X'\n      && p2esk.getPublicKey() === 'p2pk67SFY4XDMaACBrbJfvhmfLVx3wNfNt4inWHRsCdZc13b7CASxbm', \n      'FN: decryptKey p2esk')\n\n  }\n}\n\nconst main = async () => {\n  await fn_tests()\n}\n\nmain()"]}